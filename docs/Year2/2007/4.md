# 4. Threads

## OS perspective
- A process consists of two **fundamental units**
	- **Resources**: All related resources are grouped together
	- **Execution trace**: an entity that gets executed
- A process can share its resources between multiple execution traces/threads

![](../_resources/20221011131748.png)

- Every thread has its own execution context (program counter, stack registers)
- All threads have access to the process shared resources. Global variables, memory etc
- The execution of a process has states. **States** and **transitions** (new, running, blocked, ready, terminated)
- Every thread has a **thread control block**
- Threads incur less overhead to create/terminate/switch
- Hyper threaded cores have hardware support for multi-threading

//18 mins in rewatch

- **Inter-thread communication**: Easier/faster than interprocess communication (memory is shared)
- **No protection boundaries**: Required in the address space )threads are cooperating, belong to the same user, and have a common goal
- **Synchronisation**: Has to be considered carefully

## Why use threads
- Multiple **related activities** apply to the same resources, these resources should be accessible/shared
- Processes will often contain multiple blocking tasks
	- IO operations
	- Memory access: page faults
- Such activities should be carried out in parallel/concurrently
- **Application examples**: webservers, make program etc interprocess

## User Threads
- **Thread management** (creating, destroying, scheduling, thread control block manipulation) is carried out in user space with the help of a user library
- The process maintains a thread table managed by the runtime system without the kernels knowledge.
- Advantages:
	- Threads are in user space
	- Full control over the thread scheduler
	- OS independent (run on OS that doesn't support it)
- Disadvantages:
	- Blocking system calls suspend the entire process
	- No true parallelism
	- Clock interrupts are non-existent
	- Page faults result in blocking the process

## Kernel Threads
- The kernel manages threads - user applications access threading through system calls
	- Thread table is maintained by the kernel
	- If a thread blocks, the kernel chooses thread from same or different process
- Advantages:
	- True parallelism can be achieved
	- No run-time needed
- Frequent mode switches take place

## Performance
- Null fork: the overhead is creating, scheduling, running and terminating a null process/thread
- Signal wait: overhead is synchronising threads

## Hybrid Implementations
- User threads are multiplexed onto kernel threads
- Kernel sees and schedules the kernel threads
- User application sees user threads and creates/schedules these

## Thread Management
- Thread libraries provide an API/interface for managing threads
- Thread libraries can be implemented:
	- Entirely in user space
	- Based on system calls
- Examples of thread APIs include POSIX's PThreads, Windows Threads, and Java threads

## POSIX Threads
- POSIX threads are a specification that anyone can implement.