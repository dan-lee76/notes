"use strict";(self.webpackChunknottes=self.webpackChunknottes||[]).push([[8341],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>h});var n=a(67294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s=n.createContext({}),p=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},c=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=p(a),h=i,m=u["".concat(s,".").concat(h)]||u[h]||d[h]||r;return a?n.createElement(m,o(o({ref:t},c),{},{components:a})):n.createElement(m,o({ref:t},c))}));function h(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,o=new Array(r);o[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,o[1]=l;for(var p=2;p<r;p++)o[p]=a[p];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},58147:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>l,toc:()=>p});var n=a(87462),i=(a(67294),a(3905));const r={},o=void 0,l={unversionedId:"Year3/4101/reading",id:"Year3/4101/reading",title:"reading",description:"Chapter 1 - Basic Static Analysis",source:"@site/docs/Year3/4101/reading.md",sourceDirName:"Year3/4101",slug:"/Year3/4101/reading",permalink:"/Year3/4101/reading",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"year3",previous:{title:"Persistence",permalink:"/Year3/4101/14"},next:{title:"revision",permalink:"/Year3/4101/revision"}},s={},p=[{value:"Chapter 1 - Basic Static Analysis",id:"chapter-1---basic-static-analysis",level:2},{value:"Chapter 2 - Basic Dynamic Analysis",id:"chapter-2---basic-dynamic-analysis",level:2},{value:"Chapter 4 - Crash course of x86 Disassembly",id:"chapter-4---crash-course-of-x86-disassembly",level:2},{value:"Flags",id:"flags",level:3},{value:"The Stack",id:"the-stack",level:3},{value:"Chapter 6",id:"chapter-6",level:2},{value:"Recognising for loops",id:"recognising-for-loops",level:3},{value:"Chapter 7",id:"chapter-7",level:2},{value:"Chapter 11 - Malware Behaviour",id:"chapter-11---malware-behaviour",level:2},{value:"Windows Reverse Shells",id:"windows-reverse-shells",level:3},{value:"Basic",id:"basic",level:4},{value:"Multithreaded",id:"multithreaded",level:4},{value:"GINA Interception",id:"gina-interception",level:3},{value:"Hash Dumping",id:"hash-dumping",level:3},{value:"Key Loggers",id:"key-loggers",level:3},{value:"AppInit_DLLs",id:"appinit_dlls",level:3},{value:"SvcHost DLLs",id:"svchost-dlls",level:3},{value:"Trojanized System Binaries",id:"trojanized-system-binaries",level:3},{value:"Chapter 12 - Covert Malware Launching",id:"chapter-12---covert-malware-launching",level:2},{value:"Chapter 13 - Data Encoding",id:"chapter-13---data-encoding",level:2},{value:"Chapter 15 - Anti Disassembly",id:"chapter-15---anti-disassembly",level:2}],c={toc:p};function d(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"chapter-1---basic-static-analysis"},"Chapter 1 - Basic Static Analysis"),(0,i.kt)("p",null,"ASCII strings use 1 byte per char, unicode 2\n0x00 at the end is the NULL terminator"),(0,i.kt)("p",null,"Files can be compressed, a wrapper program will be in the program to decompress the packed file\nCan use PEiD program to detect the type of packer or compiler employed"),(0,i.kt)("p",null,"Portable Executable File Format (PE) is used by windows executables. OS loader to manage the wrapped executable code."),(0,i.kt)("p",null,"Static linking imports linked libraries into the executable, which makes it harder to decode/analyse"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},".text")," - Contains the instructions which the CPU executes\n",(0,i.kt)("inlineCode",{parentName:"p"},".rdata")," - Import and export information\n",(0,i.kt)("inlineCode",{parentName:"p"},".data")," - Programs global data which is accessible from anywhere in the program\n",(0,i.kt)("inlineCode",{parentName:"p"},".rsrc")," - Resources used by the executable that are not considered part of the executable, icons, imgs, strings etc"),(0,i.kt)("h2",{id:"chapter-2---basic-dynamic-analysis"},"Chapter 2 - Basic Dynamic Analysis"),(0,i.kt)("p",null,"Procmon captures a lot of data, however it doesnt capture everything. Misses device driver activity of user-mode component talking to a rootkit via device I/O, UI calls."),(0,i.kt)("h2",{id:"chapter-4---crash-course-of-x86-disassembly"},"Chapter 4 - Crash course of x86 Disassembly"),(0,i.kt)("p",null,"General registers, 32 bits in size, and can be referenced as either 32 or 16 bits in assembly."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"EDX")," - Reference the full 32-bit register\n",(0,i.kt)("inlineCode",{parentName:"p"},"EAX"),",",(0,i.kt)("inlineCode",{parentName:"p"},"EBX"),",",(0,i.kt)("inlineCode",{parentName:"p"},"ECX"),",",(0,i.kt)("inlineCode",{parentName:"p"},"EDX")," - Can be referenced as 8-bit values using the lowest 8 bits."),(0,i.kt)("h3",{id:"flags"},"Flags"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"ZF")," - Zero flag is set when the result of an operation is = 0\n",(0,i.kt)("inlineCode",{parentName:"p"},"CF")," - Carry flag is set when the result of an operation is too large or too small\n",(0,i.kt)("inlineCode",{parentName:"p"},"SF")," - Sign flag is set when the result of an operation is negative or cleared when the result is positive\n",(0,i.kt)("inlineCode",{parentName:"p"},"TF")," - Trap flag is used for debugging"),(0,i.kt)("h3",{id:"the-stack"},"The Stack"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"ESP")," - Stack Pointer\n",(0,i.kt)("inlineCode",{parentName:"p"},"EBP")," - Base pointer"),(0,i.kt)("h2",{id:"chapter-6"},"Chapter 6"),(0,i.kt)("p",null,"Local variables would be stored on the stark, whereas global would be stored in memory.\nConditional statements would use ",(0,i.kt)("inlineCode",{parentName:"p"},"jnz"),"\n",(0,i.kt)("inlineCode",{parentName:"p"},"cmp")," is comparison between to vars"),(0,i.kt)("h3",{id:"recognising-for-loops"},"Recognising for loops"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Can be located by the four components")),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Initialisation"),(0,i.kt)("li",{parentName:"ol"},"Comparison"),(0,i.kt)("li",{parentName:"ol"},"Execution instructions"),(0,i.kt)("li",{parentName:"ol"},"Increment/decrement")),(0,i.kt)("p",null,"Items are added right to left"),(0,i.kt)("h2",{id:"chapter-7"},"Chapter 7"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"DWORD"),"/",(0,i.kt)("inlineCode",{parentName:"p"},"dw")," = 32-bit word\n",(0,i.kt)("inlineCode",{parentName:"p"},"WORD"),"/",(0,i.kt)("inlineCode",{parentName:"p"},"w")," = 16-bit word\n",(0,i.kt)("inlineCode",{parentName:"p"},"H")," = Handles. Reference to an object\n",(0,i.kt)("inlineCode",{parentName:"p"},"LP")," = Long Pointer. Pointer to another type"),(0,i.kt)("h2",{id:"chapter-11---malware-behaviour"},"Chapter 11 - Malware Behaviour"),(0,i.kt)("h3",{id:"windows-reverse-shells"},"Windows Reverse Shells"),(0,i.kt)("p",null,"Two simple malware coding implementations for ",(0,i.kt)("inlineCode",{parentName:"p"},"cmd.exe")," - basic and multithreaded"),(0,i.kt)("h4",{id:"basic"},"Basic"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Easier to write, works just as well as multithreaded technique. "),(0,i.kt)("li",{parentName:"ul"},"Involves call to CreateProcess and the manipulation of the StartupInfo."),(0,i.kt)("li",{parentName:"ul"},"Socket is opened to connect to remote server"),(0,i.kt)("li",{parentName:"ul"},"Socket is then tied to the standard streams. ")),(0,i.kt)("h4",{id:"multithreaded"},"Multithreaded"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Requires socket, two pipes and two threads. "),(0,i.kt)("li",{parentName:"ul"},"Uses data encoding"),(0,i.kt)("li",{parentName:"ul"},"Used to manipulate or encode the data coming in or going out of the socket. ")),(0,i.kt)("p",null,"Remote administration tool - used to manage computer remotely.\nBotnets - Collection of compromised hosts, known as zombies, controlled by a single entity.  Goal is to compromise as many hosts as possible in order to create a large network.  "),(0,i.kt)("h3",{id:"gina-interception"},"GINA Interception"),(0,i.kt)("p",null,"Windows XP Graphical Identification and Authentication. Malware users intercept this to steal user credentials. Intended to allow legitimate third parties to customise logon process to allow for auth via 3rd party like RFID. Implemented in a DLL"),(0,i.kt)("h3",{id:"hash-dumping"},"Hash Dumping"),(0,i.kt)("p",null,"Popular way to access system credentials. Could be cracked either offline or through a pass-the-hash attack. PSH and Pwdump are open source, so a lot of malware contain these. Most antivirus programs have signatures for the default compiled versions of these tools, so attackers have to compile their own version.\nPwdump works by performing DLL injection inside the Local Security Authority Subsystem Service"),(0,i.kt)("h3",{id:"key-loggers"},"Key Loggers"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Kernel-based loggers are difficult to detect with user-mode applications. Part of a rootkit, that can act as a keyboard drivers to capture keystrokes, bypassing user-space programs and protections.")),(0,i.kt)("p",null,"User-based typically use the Windows API, implemented either by hooking or polling. Hooking uses the API to notify the malware a key is pressed. Polling constantly polls the state of the keys."),(0,i.kt)("h3",{id:"appinit_dlls"},"AppInit_DLLs"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Malware gains persistence through special registry location called ",(0,i.kt)("inlineCode",{parentName:"li"},"AppInit_DLL"),".")),(0,i.kt)("h3",{id:"svchost-dlls"},"SvcHost DLLs"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Malware will typically not create a new group, since it would be easier to detect. Instead, most malware will add itself to a pre-existing group or overwrite a nonvital service.")),(0,i.kt)("h3",{id:"trojanized-system-binaries"},"Trojanized System Binaries"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Malware patches bytes of a system binary to force the system to execute the malware the next time the binary is run or loaded."),(0,i.kt)("li",{parentName:"ul"},"Normally done by patching the entry function so it jumps to the malicious code"),(0,i.kt)("li",{parentName:"ul"},"Malware is added to empty section so does not impact normal operation. Will function no matter what. Will execute malware then jump back to normal location")),(0,i.kt)("h2",{id:"chapter-12---covert-malware-launching"},"Chapter 12 - Covert Malware Launching"),(0,i.kt)("h2",{id:"chapter-13---data-encoding"},"Chapter 13 - Data Encoding"),(0,i.kt)("h2",{id:"chapter-15---anti-disassembly"},"Chapter 15 - Anti Disassembly"),(0,i.kt)("p",null,"Linear Disassembly - Iterates over a block of code, disassembling one instruction at a time linearly without deviating.  Easiest to defeat because they are unable to distinguish between code and data."),(0,i.kt)("p",null,"Flow-oriented disassembler - Doesn't blindly iterate over a buffer, assuming the data is nothing but instructions packed neatly together. Examines each instruction and builds a list of locations to disassemble"),(0,i.kt)("p",null,"If appears in red, rather than blue, then anti-disassembly is being used"))}d.isMDXComponent=!0}}]);