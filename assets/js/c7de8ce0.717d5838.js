"use strict";(self.webpackChunknottes=self.webpackChunknottes||[]).push([[8373],{3905:(e,t,r)=>{r.d(t,{Zo:()=>u,kt:()=>m});var n=r(67294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function l(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?l(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):l(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function o(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},l=Object.keys(e);for(n=0;n<l.length;n++)r=l[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)r=l[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var s=n.createContext({}),c=function(e){var t=n.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},u=function(e){var t=c(e.components);return n.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,l=e.originalType,s=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),d=c(r),m=a,h=d["".concat(s,".").concat(m)]||d[m]||p[m]||l;return r?n.createElement(h,i(i({ref:t},u),{},{components:r})):n.createElement(h,i({ref:t},u))}));function m(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var l=r.length,i=new Array(l);i[0]=d;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:a,i[1]=o;for(var c=2;c<l;c++)i[c]=r[c];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}d.displayName="MDXCreateElement"},41467:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>p,frontMatter:()=>l,metadata:()=>o,toc:()=>c});var n=r(87462),a=(r(67294),r(3905));const l={},i="Reference Monitors",o={unversionedId:"Year3/3006/05",id:"Year3/3006/05",title:"Reference Monitors",description:"Reference Monitor",source:"@site/docs/Year3/3006/05.md",sourceDirName:"Year3/3006",slug:"/Year3/3006/05",permalink:"/Year3/3006/05",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"year3",previous:{title:"Authentication 2",permalink:"/Year3/3006/04"},next:{title:"Windows",permalink:"/Year3/3006/06"}},s={},c=[{value:"Reference Monitor",id:"reference-monitor",level:2},{value:"OS Integrity",id:"os-integrity",level:2},{value:"Modes of Operation",id:"modes-of-operation",level:3},{value:"Controlled Invocation",id:"controlled-invocation",level:3},{value:"Descriptors and Selectors",id:"descriptors-and-selectors",level:3},{value:"Interrupt Gates",id:"interrupt-gates",level:3},{value:"Privilege Elevation",id:"privilege-elevation",level:2},{value:"Process and Threads",id:"process-and-threads",level:3},{value:"Memory Protection",id:"memory-protection",level:2},{value:"Page Tables",id:"page-tables",level:3},{value:"Meltdown and Spectre",id:"meltdown-and-spectre",level:2},{value:"Meltdown",id:"meltdown",level:3},{value:"Side-Channels and Cache Timing",id:"side-channels-and-cache-timing",level:3},{value:"Spectre",id:"spectre",level:3}],u={toc:c};function p(e){let{components:t,...l}=e;return(0,a.kt)("wrapper",(0,n.Z)({},u,l,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"reference-monitors"},"Reference Monitors"),(0,a.kt)("h2",{id:"reference-monitor"},"Reference Monitor"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"An access control concept that refers to an abstract machine that mediates all access to objects by subjects")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Must be tamper proof/resistant"),(0,a.kt)("li",{parentName:"ul"},"Must always be invoked when access to an object is required"),(0,a.kt)("li",{parentName:"ul"},"Must be small enough to be verifiable/subject to analysis to ensure correctness ")),(0,a.kt)("p",null,"Can be placed anywhere within a system - Hardware, OS kernel, OS, service layer"),(0,a.kt)("p",null,"Lower is better - Can assure a higher degree of security, simple structures to implement. Reduced performance overheads. Fewer layer below attack possibilities. However, access control decisions are far removed from applications"),(0,a.kt)("h2",{id:"os-integrity"},"OS Integrity"),(0,a.kt)("p",null,"Arbitrates access requests\nIs itself a resource that must be accessed"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Users must not be able to modify the operating systems")),(0,a.kt)("p",null,"Modes of operation - Defines which actions are permitted in which mode e.g. system calls, machine instructions, I/O\nControlled Invocation - Allow us to execute privileged instructions safety, before returning to user code."),(0,a.kt)("h3",{id:"modes-of-operation"},"Modes of Operation"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Distinguish between computations done on behalf of:",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"The OS"),(0,a.kt)("li",{parentName:"ul"},"The User"))),(0,a.kt)("li",{parentName:"ul"},"A status flag within the CPU allows the OS to operate in different mode\n",(0,a.kt)("img",{src:r(33346).Z,width:"605",height:"482"}))),(0,a.kt)("h3",{id:"controlled-invocation"},"Controlled Invocation"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Many functions are held at kernel level, but are quite reasonably called from within user level code",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Network and File IO"),(0,a.kt)("li",{parentName:"ul"},"Memory allocation"),(0,a.kt)("li",{parentName:"ul"},"Privileged instructions"))),(0,a.kt)("li",{parentName:"ul"},"Need a mechanism to transfer between kernel mode (ring 0) and user mode (ring 3)")),(0,a.kt)("p",null,"Interrupts - Called various things. Handled by an interrupt handler which resolves the issue and returns to the original code\nGiven an interrupt, the CPU will switch execution to the location given in an interrupt descriptor table"),(0,a.kt)("h3",{id:"descriptors-and-selectors"},"Descriptors and Selectors"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Descriptors hold information on crucial system objects like kernel structure locations"),(0,a.kt)("li",{parentName:"ul"},"Descriptors are held in descriptor tables - Contain a Descriptor Privilege Level (DPL)"),(0,a.kt)("li",{parentName:"ul"},"Descriptors are indexed by selectors - Loaded when required"),(0,a.kt)("li",{parentName:"ul"},"The CPU protects the kernel by checking the Current Privilege Level (CPL) when a selector is loaded")),(0,a.kt)("h3",{id:"interrupt-gates"},"Interrupt Gates"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The code segment (CS) register in x86 CPUs has 2 bits reserved for the (CPL)"),(0,a.kt)("li",{parentName:"ul"},"Descriptors that have a privilege level higher than where they point are called gates"),(0,a.kt)("li",{parentName:"ul"},"Since these descriptors are created by the kernel, they offer a secure means of entry into ring 0")),(0,a.kt)("h2",{id:"privilege-elevation"},"Privilege Elevation"),(0,a.kt)("p",null,"x86 Linux initialises its IDT to handle syscalls at vector 0x80\nModern Kernels - Intel introduced the sysenter and sysexit operations with the Pentium II - much less overhead\nPatching the Kernel - If you can run customer PL 0 code (compromised driver?). you can insert your own handler - Rootkit"),(0,a.kt)("h3",{id:"process-and-threads"},"Process and Threads"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"A process is a program being executed"),(0,a.kt)("li",{parentName:"ul"},"Important unit of control:",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Exists in its own address space"),(0,a.kt)("li",{parentName:"ul"},"Communicates with other processes via the OS"),(0,a.kt)("li",{parentName:"ul"},"Separation for security"))),(0,a.kt)("li",{parentName:"ul"},"A Thread is a strand of execution within a process",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Share a common address space")))),(0,a.kt)("h2",{id:"memory-protection"},"Memory Protection"),(0,a.kt)("p",null,"Segmentation - divides data into logical units"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Good for security"),(0,a.kt)("li",{parentName:"ul"},"Challenging memory management"),(0,a.kt)("li",{parentName:"ul"},"Not used much in modern OSs\nPaging - divides memory into pages of equal size"),(0,a.kt)("li",{parentName:"ul"},"Efficient memory management"),(0,a.kt)("li",{parentName:"ul"},"Less good for access control"),(0,a.kt)("li",{parentName:"ul"},"Extremely common in modern OSs")),(0,a.kt)("h3",{id:"page-tables"},"Page Tables"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"All processes see an individual linear address space"),(0,a.kt)("li",{parentName:"ul"},"Page tables map from a linear address space to the physical address space")),(0,a.kt)("h2",{id:"meltdown-and-spectre"},"Meltdown and Spectre"),(0,a.kt)("h3",{id:"meltdown"},"Meltdown"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"In most OS, the entire kernel is stored in the upper address space"),(0,a.kt)("li",{parentName:"ul"},"Pages in this area are flagged as supervisor, and cannot be accessed outside of ring 0"),(0,a.kt)("li",{parentName:"ul"},"Meltdown is an exploit that allows us to read this privileged memory",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Do this using a side-channel"))),(0,a.kt)("li",{parentName:"ul"},"Attempts to read a value from kernel memory",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Read from kernel"),(0,a.kt)("li",{parentName:"ul"},"Mask out a single bit"),(0,a.kt)("li",{parentName:"ul"},"Access user memory at that location")))),(0,a.kt)("h3",{id:"side-channels-and-cache-timing"},"Side-Channels and Cache Timing"),(0,a.kt)("p",null,"Intel CPUs, its common to speculatively evaluate code prior to reaching it"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Conditionals"),(0,a.kt)("li",{parentName:"ul"},"Significant speed up"),(0,a.kt)("li",{parentName:"ul"},"No harm done! Changes are rolled back"),(0,a.kt)("li",{parentName:"ul"},"But, the cache isn't rolled back")),(0,a.kt)("h3",{id:"spectre"},"Spectre"),(0,a.kt)("p",null,"Very similar to meltdown"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Speculative evaluation to side-step application bounds check"),(0,a.kt)("li",{parentName:"ul"},"Mask out a single bit"),(0,a.kt)("li",{parentName:"ul"},"Access suer memory at that location")))}p.isMDXComponent=!0},33346:(e,t,r)=>{r.d(t,{Z:()=>n});const n=r.p+"assets/images/3006_05-a88f1594e105add4143facb7713b3773.png"}}]);