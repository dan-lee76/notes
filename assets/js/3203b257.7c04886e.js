"use strict";(self.webpackChunknottes=self.webpackChunknottes||[]).push([[3337],{3905:(e,t,i)=>{i.d(t,{Zo:()=>c,kt:()=>d});var a=i(7294);function n(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}function l(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,a)}return i}function r(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?l(Object(i),!0).forEach((function(t){n(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):l(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}function o(e,t){if(null==e)return{};var i,a,n=function(e,t){if(null==e)return{};var i,a,n={},l=Object.keys(e);for(a=0;a<l.length;a++)i=l[a],t.indexOf(i)>=0||(n[i]=e[i]);return n}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)i=l[a],t.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(e,i)&&(n[i]=e[i])}return n}var s=a.createContext({}),m=function(e){var t=a.useContext(s),i=t;return e&&(i="function"==typeof e?e(t):r(r({},t),e)),i},c=function(e){var t=m(e.components);return a.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var i=e.components,n=e.mdxType,l=e.originalType,s=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),p=m(i),d=n,g=p["".concat(s,".").concat(d)]||p[d]||u[d]||l;return i?a.createElement(g,r(r({ref:t},c),{},{components:i})):a.createElement(g,r({ref:t},c))}));function d(e,t){var i=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var l=i.length,r=new Array(l);r[0]=p;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:n,r[1]=o;for(var m=2;m<l;m++)r[m]=i[m];return a.createElement.apply(null,r)}return a.createElement.apply(null,i)}p.displayName="MDXCreateElement"},3627:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>u,frontMatter:()=>l,metadata:()=>o,toc:()=>m});var a=i(7462),n=(i(7294),i(3905));const l={},r="14. Dynamic Partitioning & Paging",o={unversionedId:"Year2/2007/14",id:"Year2/2007/14",title:"14. Dynamic Partitioning & Paging",description:"07/11/22",source:"@site/docs/Year2/2007/14.md",sourceDirName:"Year2/2007",slug:"/Year2/2007/14",permalink:"/Year2/2007/14",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"year2",previous:{title:"13. Memory Management 2",permalink:"/Year2/2007/13"},next:{title:"15. Paging & Virtual Memory",permalink:"/Year2/2007/15"}},s={},m=[{value:"Dynamic Partitioning",id:"dynamic-partitioning",level:2},{value:"Allocating Available Memory",id:"allocating-available-memory",level:3},{value:"First Fit",id:"first-fit",level:4},{value:"Next fit",id:"next-fit",level:4},{value:"First &amp; Next fit",id:"first--next-fit",level:4},{value:"Best Fit",id:"best-fit",level:4},{value:"Worst Fit",id:"worst-fit",level:4},{value:"Summary",id:"summary",level:3},{value:"Quick fit",id:"quick-fit",level:3},{value:"Managing available memory",id:"managing-available-memory",level:3},{value:"Coalescing",id:"coalescing",level:4},{value:"Compacting",id:"compacting",level:4},{value:"Contiguous Allocation Schemes",id:"contiguous-allocation-schemes",level:2},{value:"Paging",id:"paging",level:2},{value:"Definitions",id:"definitions",level:3},{value:"Relocation",id:"relocation",level:3}],c={toc:m};function u(e){let{components:t,...l}=e;return(0,n.kt)("wrapper",(0,a.Z)({},c,l,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"14-dynamic-partitioning--paging"},"14. Dynamic Partitioning & Paging"),(0,n.kt)("p",null,(0,n.kt)("em",{parentName:"p"},"07/11/22")),(0,n.kt)("h2",{id:"dynamic-partitioning"},"Dynamic Partitioning"),(0,n.kt)("p",null,"Operating system is responsible for applying strategies to allocate processes to available memory and managing free space"),(0,n.kt)("h3",{id:"allocating-available-memory"},"Allocating Available Memory"),(0,n.kt)("h4",{id:"first-fit"},"First Fit"),(0,n.kt)("p",null,"Starts scanning from the start of the linked list until a link is found which represents free space of sufficient size"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"If requested space is the exact same size as the 'hole', ass the space is allocated"),(0,n.kt)("li",{parentName:"ul"},"Else the free link is split into two",(0,n.kt)("pre",{parentName:"li"},(0,n.kt)("code",{parentName:"pre"},"- First entry is set to the size requested and marked 'used'\n- The secondary entry is set to remaining size and marked 'free'\n")))),(0,n.kt)("h4",{id:"next-fit"},"Next fit"),(0,n.kt)("p",null,"Maintains a record of where it got to"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Restarts its search from where it stopped last time"),(0,n.kt)("li",{parentName:"ul"},"Gives an even chance to all memory to get allocated\nHowever, simulations have shown that next fit actually gives worse performance than first fit")),(0,n.kt)("h4",{id:"first--next-fit"},"First & Next fit"),(0,n.kt)("p",null,"First fit is a fast allocation method that just looks for the first available hole. Doesn't take into account if there is a hole later, and can break up big holes\nNext fit doesn't improve that model."),(0,n.kt)("h4",{id:"best-fit"},"Best Fit"),(0,n.kt)("p",null,"Best fit always searches the entire linked list to find the smallest hole big enough to satisfy the memory request. Its slower than first git, and can also result in more wasted memory (tiny useless holes)"),(0,n.kt)("h4",{id:"worst-fit"},"Worst Fit"),(0,n.kt)("p",null,"Tiny holes are created when best fit splits an empty partition. The worst fit algorithm finds the largest available empty partition and splits it. Left over part will still be large and potentially more useful. "),(0,n.kt)("h3",{id:"summary"},"Summary"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"First fit"),": allocate first block that is large enough"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Next fit"),": allocate next block that is large enough, i.e. starting from the current location"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Best fit"),": choose block that matches required size closest - O(N) complexity"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Worst fit"),": choose the largest possible block - O(N) complexity ")),(0,n.kt)("h3",{id:"quick-fit"},"Quick fit"),(0,n.kt)("p",null,(0,n.kt)("img",{src:i(8823).Z,width:"474",height:"284"})),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Maintains lists of commonly used sizes",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"Odd sizes can either go into the nearest size or into a special separate list"))),(0,n.kt)("li",{parentName:"ul"},"It is much faster to find the required size hole using quick fit"),(0,n.kt)("li",{parentName:"ul"},"Similar to best fit, it has the problem of creating many tiny holes"),(0,n.kt)("li",{parentName:"ul"},"Finding neighbours for coalescing becomes more difficult/time consuming ")),(0,n.kt)("h3",{id:"managing-available-memory"},"Managing available memory"),(0,n.kt)("h4",{id:"coalescing"},"Coalescing"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Coalescing (joining together) takes place when two adjacent entries in the linked list becomes free."),(0,n.kt)("li",{parentName:"ul"},"Both neighbours are examined when a block is freed",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"If either/both blocks are free, they are combined into one larger block by adding up the sizes")))),(0,n.kt)("h4",{id:"compacting"},"Compacting"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Even with coalescing happening automatically, free blocks may still distributed across memory",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"Can be used to join free and used memory together "))),(0,n.kt)("li",{parentName:"ul"},"Compacting is more difficult and time consuming to implement than coalescing ")),(0,n.kt)("h2",{id:"contiguous-allocation-schemes"},"Contiguous Allocation Schemes"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Different contiguous memory allocation schemes have different advantages/disadvantages",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"Mono-programming: easy but does result in low resource utilisation"),(0,n.kt)("li",{parentName:"ul"},"Fixed partitioning facilitates multi-programming but results in internal fragmentation"),(0,n.kt)("li",{parentName:"ul"},"Dynamic partitioning facilitates multi-programming, reduces internal fragmentation, but results in external fragmentation")))),(0,n.kt)("h2",{id:"paging"},"Paging"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Uses the principles of fixed partitioning and core relocation to devise a new ",(0,n.kt)("strong",{parentName:"li"},"non-contiguous")," management scheme:",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"Memory is split into much smaller blocks and one or multiple blocks are allocated to a process"),(0,n.kt)("li",{parentName:"ul"},"These blocks do not have to be contiguous in main memory, but the process still perceives them to be contiguous"))),(0,n.kt)("li",{parentName:"ul"},"Benefits compared to contiguous scheme include:",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"Internal fragmentation is reduced to the last block only"),(0,n.kt)("li",{parentName:"ul"},"There is no external fragmentation, since physical blocks are stacked directly onto each other in main memory")))),(0,n.kt)("h3",{id:"definitions"},"Definitions"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Small block of contiguous memory in the logical address space"),(0,n.kt)("li",{parentName:"ul"},"A frame is a small contiguous block in physical memory"),(0,n.kt)("li",{parentName:"ul"},"Pages and frames usually have the same size")),(0,n.kt)("h3",{id:"relocation"},"Relocation"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Logical address needs to be translated into a physical address")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Multiple 'base registers' will be required.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Base registers are stored in the page table"),(0,n.kt)("p",{parentName:"li"}," ",(0,n.kt)("img",{src:i(8690).Z,width:"960",height:"718"}),"\nPage tables may not be efficient as more address there are , the bigger it gets and the slower it is"))))}u.isMDXComponent=!0},8823:(e,t,i)=>{i.d(t,{Z:()=>a});const a=i.p+"assets/images/20221107131907-1115e0fd66ccd0bf732edf9152bdb76b.png"},8690:(e,t,i)=>{i.d(t,{Z:()=>a});const a=i.p+"assets/images/20221107151513-7afd029077d12fc33448f33bc7b55ddb.png"}}]);