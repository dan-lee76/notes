"use strict";(self.webpackChunknottes=self.webpackChunknottes||[]).push([[9016],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>d});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),u=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},p=function(e){var t=u(e.components);return n.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),m=u(a),d=r,h=m["".concat(s,".").concat(d)]||m[d]||c[d]||i;return a?n.createElement(h,l(l({ref:t},p),{},{components:a})):n.createElement(h,l({ref:t},p))}));function d(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,l=new Array(i);l[0]=m;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:r,l[1]=o;for(var u=2;u<i;u++)l[u]=a[u];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},5097:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>c,frontMatter:()=>i,metadata:()=>o,toc:()=>u});var n=a(7462),r=(a(7294),a(3905));const i={},l="8. Mutexs & Stemaphores",o={unversionedId:"Year2/2007/8",id:"Year2/2007/8",title:"8. Mutexs & Stemaphores",description:"21/10/22",source:"@site/docs/Year2/2007/8.md",sourceDirName:"Year2/2007",slug:"/Year2/2007/8",permalink:"/Year2/2007/8",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"year2",previous:{title:"7. Concurrency (2)",permalink:"/Year2/2007/7"},next:{title:"9.",permalink:"/Year2/2007/9"}},s={},u=[{value:"Mutex Locks",id:"mutex-locks",level:2},{value:"Semaphores",id:"semaphores",level:2},{value:"Efficiency",id:"efficiency",level:2},{value:"Caveats",id:"caveats",level:2},{value:"The Producer/Consumer Problem",id:"the-producerconsumer-problem",level:2},{value:"First Version",id:"first-version",level:3},{value:"Second Version",id:"second-version",level:3}],p={toc:u};function c(e){let{components:t,...i}=e;return(0,r.kt)("wrapper",(0,n.Z)({},p,i,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"8-mutexs--stemaphores"},"8. Mutexs & Stemaphores"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"21/10/22 ")),(0,r.kt)("h2",{id:"mutex-locks"},"Mutex Locks"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Mutexes are an approach for mutual exclusion provided by the operating system.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Contains boolean lock variable to indicate"),(0,r.kt)("li",{parentName:"ul"},"Lock variable is set to ",(0,r.kt)("strong",{parentName:"li"},"true")," if the lock is ",(0,r.kt)("strong",{parentName:"li"},"available"),". ",(0,r.kt)("strong",{parentName:"li"},"false")," if ",(0,r.kt)("strong",{parentName:"li"},"unavailable")))),(0,r.kt)("li",{parentName:"ul"},"Two Functions used. These must be atomic instructions:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"acquire()")," - called before a critical selection, sets bool to false"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"release()")," - called after the critical section, sets bool to true"))),(0,r.kt)("li",{parentName:"ul"},"The process that acquires the lock must release the lock"),(0,r.kt)("li",{parentName:"ul"},"Key disadvantage of mutex locks is that calls to ",(0,r.kt)("inlineCode",{parentName:"li"},"acquire()")," result in busy waiting. Detrimental for performance on single CPU systems."),(0,r.kt)("li",{parentName:"ul"},"Key advantages of mutex locks include:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Context switches can be avoided"),(0,r.kt)("li",{parentName:"ul"},"Efficient on multi-core/multi-processor systems when locks are he,d for a short time only"))),(0,r.kt)("li",{parentName:"ul"},"Single core is easy to waste time, multi core higher chance it gets released quickly as it could be on a separate core")),(0,r.kt)("p",null,"Mutexs binary lock "),(0,r.kt)("p",null,(0,r.kt)("img",{src:a(770).Z,width:"411",height:"590"}),"\n",(0,r.kt)("em",{parentName:"p"},"Mutex Example")),(0,r.kt)("p",null,(0,r.kt)("img",{src:a(5229).Z,width:"1403",height:"214"}),"\n",(0,r.kt)("em",{parentName:"p"},"Mutex Example")),(0,r.kt)("h2",{id:"semaphores"},"Semaphores"),(0,r.kt)("p",null,"Doing the opposite, put the process on the execution, and puts it to sleep."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Semaphores are an approach to mutual exclusion provided by the operating system",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Contain an integer variable"),(0,r.kt)("li",{parentName:"ul"},"Well distinguish between binary (If negative means processes are available.) and counting semaphores. (User uses it so it can go above 1.) "),(0,r.kt)("li",{parentName:"ul"},"Can be used to force mutual exclusion, and represent resources"))),(0,r.kt)("li",{parentName:"ul"},"Two atomic functions:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"wait()")," - called when a resource is acquired, the counter is decremented"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"signal()"),"/",(0,r.kt)("inlineCode",{parentName:"li"},"post()")," - is called when a resource is released"))),(0,r.kt)("li",{parentName:"ul"},"Strictly positive values indicate that the semaphore is available, negative values indicate the number of processes/threads waiting")),(0,r.kt)("p",null,(0,r.kt)("img",{src:a(2310).Z,width:"1120",height:"552"}),"\n",(0,r.kt)("em",{parentName:"p"},"Semaphores example")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Calling ",(0,r.kt)("inlineCode",{parentName:"li"},"wait()")," will block the process/thread when the internal counter is negative",(0,r.kt)("ol",{parentName:"li"},(0,r.kt)("li",{parentName:"ol"},"Process/thread joins the blocked queue"),(0,r.kt)("li",{parentName:"ol"},"Process/thread state is changed from running to blocked"),(0,r.kt)("li",{parentName:"ol"},"Control is transferred to the process scheduler"))),(0,r.kt)("li",{parentName:"ul"},"Calling ",(0,r.kt)("inlineCode",{parentName:"li"},"post()")," removes a process/thread from the blocked queue if the counter is equal to or less than 0",(0,r.kt)("ol",{parentName:"li"},(0,r.kt)("li",{parentName:"ol"},"Process/thread state is changed from blocked to ready"),(0,r.kt)("li",{parentName:"ol"},"Joins the read queue"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Different queuing strategies can be employed to remove processes/threads. Queue as FIFO")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"block()")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"wakeup()")," are system calls provided by the OS"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"post()")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"wait()")," must be atomic. Can be achieved through mutexes. Busy waiting is moved from the critical section to ",(0,r.kt)("inlineCode",{parentName:"li"},"wait()")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"post()")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("img",{src:a(8696).Z,width:"1012",height:"578"}),(0,r.kt)("em",{parentName:"li"},"Mutexes vs Semaphores"))),(0,r.kt)("p",null,"Mutexs can be implemented as semaphore."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Semaphores within the same process can be declared as global variables of the type ",(0,r.kt)("inlineCode",{parentName:"li"},"sem_t"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"sem_init()")," - initialises the value of the semaphore"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"sem_wait()")," - decrements the value of the semaphore"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"sem_post()")," - increments the values of the semaphore ")))),(0,r.kt)("h2",{id:"efficiency"},"Efficiency"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Synchronising code does result in a performance penalty",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Synchronise only when necessary"),(0,r.kt)("li",{parentName:"ul"},"Synchronise a few instructions as possible (unnecessary instructions will delay others when entering critical state)")))),(0,r.kt)("h2",{id:"caveats"},"Caveats"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Starvation: Poorly designed queuing approaches (LIFO) may result in fairness violations"),(0,r.kt)("li",{parentName:"ul"},"Deadlocks: Every thread in a set is waiting for an even that can only be caused by another thread in the same set"),(0,r.kt)("li",{parentName:"ul"},"Priority inversion: high priority process waits for a resource held by a low priority process"),(0,r.kt)("li",{parentName:"ul"},"Priority inversion can happen in chains. Prevented by priority inheritance/boosting")),(0,r.kt)("h2",{id:"the-producerconsumer-problem"},"The Producer/Consumer Problem"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Producers and consumers share ",(0,r.kt)("em",{parentName:"li"},"N")," buffers that are capable of holding one item each.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Buffer can be bounded or unbounded size"),(0,r.kt)("li",{parentName:"ul"},"Can be one or multiple consumers and/or producers"))),(0,r.kt)("li",{parentName:"ul"},"The producer(s) adds items and goes to sleep if the bugger is full"),(0,r.kt)("li",{parentName:"ul"},"The consumer(S) removes items and goes to sleep if the buffer is empty")),(0,r.kt)("h3",{id:"first-version"},"First Version"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"One producer, one consumer, and an unbounded buffer. "),(0,r.kt)("li",{parentName:"ul"},"A counter (index) represents the number of items in the buffer"),(0,r.kt)("li",{parentName:"ul"},"The solution uses two binary semaphores:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"sync"),": synchronises access to the buffer (counter) - initialised to 1"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"delay_consumer"),": puts the consumer to sleep when the buffer is empty - initialised to 0")))),(0,r.kt)("p",null,(0,r.kt)("img",{src:a(8583).Z,width:"1475",height:"551"}),"\n",(0,r.kt)("em",{parentName:"p"},"Single producer/consumer with unbounded buffer")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Any manipulations of count will have to be synchronised. "),(0,r.kt)("li",{parentName:"ul"},"Race conditions still exist",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"When the consumer has exhausted the buffer, should have gone to sleep, but the producer increments ",(0,r.kt)("inlineCode",{parentName:"li"},"items")," before the consumer checks it")))),(0,r.kt)("h3",{id:"second-version"},"Second Version"),(0,r.kt)("p",null,(0,r.kt)("img",{src:a(6551).Z,width:"1475",height:"551"}),"\n",(0,r.kt)("em",{parentName:"p"},"Single producer/consumer and an unbounded bugger: Race condition (items = -1")))}c.isMDXComponent=!0},770:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/20221021180257-b7715d6643d99041c8f14bf6755585d4.png"},5229:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/20221021180339-0e74f7e68524965e5315a8a28181304e.png"},2310:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/20221021180514-74268391b4c10cf85686cb55cec8785e.png"},8696:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/20221021180600-43f499d7beae09d729b5e544921b8a68.png"},8583:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/20221021180655-7051af2cbed9842724242728fdd71cfa.png"},6551:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/20221021180723-4f57be3cdf09ea7c6c266265bdf7ee06.png"}}]);