"use strict";(self.webpackChunknottes=self.webpackChunknottes||[]).push([[2985],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>m});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),u=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},p=function(e){var t=u(e.components);return n.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),h=u(a),m=r,d=h["".concat(s,".").concat(m)]||h[m]||c[m]||i;return a?n.createElement(d,l(l({ref:t},p),{},{components:a})):n.createElement(d,l({ref:t},p))}));function m(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,l=new Array(i);l[0]=h;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:r,l[1]=o;for(var u=2;u<i;u++)l[u]=a[u];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},92:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>c,frontMatter:()=>i,metadata:()=>o,toc:()=>u});var n=a(87462),r=(a(67294),a(3905));const i={},l="Hash Functions",o={unversionedId:"Year3/3077/06",id:"Year3/3077/06",title:"Hash Functions",description:"Properties of Cryptographically Secure Hash Functions",source:"@site/docs/Year3/3077/06.md",sourceDirName:"Year3/3077",slug:"/Year3/3077/06",permalink:"/Year3/3077/06",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"year3",previous:{title:"DES and Cryptanalysis",permalink:"/Year3/3077/05"},next:{title:"Finite Field Arithmetic",permalink:"/Year3/3077/07"}},s={},u=[{value:"Properties of Cryptographically Secure Hash Functions",id:"properties-of-cryptographically-secure-hash-functions",level:2},{value:"Birthday Paradox",id:"birthday-paradox",level:2},{value:"Birthday attack",id:"birthday-attack",level:3},{value:"Merkle-Damgard",id:"merkle-damgard",level:2},{value:"Padding",id:"padding",level:2},{value:"Compression Function",id:"compression-function",level:2},{value:"Avalanche Effect",id:"avalanche-effect",level:2},{value:"Password Hashing",id:"password-hashing",level:2},{value:"Password Salting",id:"password-salting",level:2},{value:"Just Break Property 3",id:"just-break-property-3",level:2}],p={toc:u};function c(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"hash-functions"},"Hash Functions"),(0,r.kt)("h2",{id:"properties-of-cryptographically-secure-hash-functions"},"Properties of Cryptographically Secure Hash Functions"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Any input length"),(0,r.kt)("li",{parentName:"ol"},"Fixed output length"),(0,r.kt)("li",{parentName:"ol"},"Fast"),(0,r.kt)("li",{parentName:"ol"},"Preimage resistance (one way)"),(0,r.kt)("li",{parentName:"ol"},"Second preimage resistance"),(0,r.kt)("li",{parentName:"ol"},"Collision resistance")),(0,r.kt)("p",null,"Preimage Resistance"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Hash functions must be one-way"),(0,r.kt)("li",{parentName:"ul"},"Given a hash of a message H(x) it must be infeasible to calculate x"),(0,r.kt)("li",{parentName:"ul"},"Less applicable to digital signatures, crucial for e.g. password storage and key derivation")),(0,r.kt)("p",null,"Second Preimage Resistance"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Weak collision resistance"),(0,r.kt)("li",{parentName:"ul"},"Given a message x_0 and a has of that message it should be infeasible to find a second message ...")),(0,r.kt)("p",null,"Collision Resistance"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Strong collision resistance"),(0,r.kt)("li",{parentName:"ul"},"It is not possible to find any message pair such that.."),(0,r.kt)("li",{parentName:"ul"},"In practice, this is much easier than finding a weak collision")),(0,r.kt)("p",null,"Preventing Collisions"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"If you attempt to fit more messages into fewer hash spaces, collisions are guaranteed")),(0,r.kt)("p",null,"Second Preimage Attacks - For a 256 bit hash with good random properies might expect 2^256 bit brute force resistance before we find a collision with x_0"),(0,r.kt)("p",null,"Collision Attacks - There are many other possible collisions beyond those simply with x_0"),(0,r.kt)("h2",{id:"birthday-paradox"},"Birthday Paradox"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"It is easier to first calculate the probability P(n) that n people do not share any birthdays"),(0,r.kt)("li",{parentName:"ul"},"The probability of at least one collision is 1-P(no collision)"),(0,r.kt)("li",{parentName:"ul"},"The probability of a collision with only 23 people is 50% For 40 its 90%"),(0,r.kt)("li",{parentName:"ul"},"Same principle applies to hash functions, the more hashes computed, the more likely a collision becomes")),(0,r.kt)("h3",{id:"birthday-attack"},"Birthday attack"),(0,r.kt)("p",null,"....."),(0,r.kt)("h2",{id:"merkle-damgard"},"Merkle-Damgard"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Many families of hash functions use a Merkle-Damgard construction"),(0,r.kt)("li",{parentName:"ul"},"The message is added in one block at a time"),(0,r.kt)("li",{parentName:"ul"},"Message blocks are mixed with the previous hash state using a compression function"),(0,r.kt)("li",{parentName:"ul"},"...")),(0,r.kt)("h2",{id:"padding"},"Padding"),(0,r.kt)("p",null,"..."),(0,r.kt)("h2",{id:"compression-function"},"Compression Function"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The compression function mixes 512 bit blocks of message into the current state to produce a new state"),(0,r.kt)("li",{parentName:"ul"},"The message schedule expands 512 bits to 64 x 32 bit words"),(0,r.kt)("li",{parentName:"ul"},"Each round performs permutation and mixing"),(0,r.kt)("li",{parentName:"ul"},"Conceptually similar to a block cipher, and some hash functions are implemented this way")),(0,r.kt)("h2",{id:"avalanche-effect"},"Avalanche Effect"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Whenever the input is changed at all, each output bit should change with 50% probability")),(0,r.kt)("h2",{id:"password-hashing"},"Password Hashing"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Preimage Protection means we cannot derive x from H(x) any more easily than brute force"),(0,r.kt)("li",{parentName:"ul"},"This is ideal for storing passwords, we store H(x) and then compare to H(y) where y is whatever the user submits"),(0,r.kt)("li",{parentName:"ul"},"When, not if, your database is exposed you dont expose user passwords"),(0,r.kt)("li",{parentName:"ul"},"Property 3 of Hash Functions: Fast"),(0,r.kt)("li",{parentName:"ul"},"Fast functions, are fast to brute force")),(0,r.kt)("h2",{id:"password-salting"},"Password Salting"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Attacking hash functions often uses Rainbow Tables, precomputed hashes"),(0,r.kt)("li",{parentName:"ul"},"We can resist this by not storing H(X), but instead H(x+s)"),(0,r.kt)("li",{parentName:"ul"},"If s is unique per user, then any Rainbow Table must be unique per user too"),(0,r.kt)("li",{parentName:"ul"},"Salting means an attack has to brute force per user")),(0,r.kt)("h2",{id:"just-break-property-3"},"Just Break Property 3"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A password hash function can be x times slower and not meaningfully impact user experience"),(0,r.kt)("li",{parentName:"ul"},"Take a known fast hash function and repeat it"),(0,r.kt)("li",{parentName:"ul"},"PBKDF creates a hash by repeatedly hashing the password, up to 100,000 times and xoring the results together"),(0,r.kt)("li",{parentName:"ul"},"Balloon Hashing will create a large array of hashes and work back and forth over that increasing not just the time but the memory cost")))}c.isMDXComponent=!0}}]);