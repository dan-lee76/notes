"use strict";(self.webpackChunknottes=self.webpackChunknottes||[]).push([[2418],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),c=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=c(e.components);return r.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=c(n),m=a,h=d["".concat(s,".").concat(m)]||d[m]||p[m]||i;return n?r.createElement(h,o(o({ref:t},u),{},{components:n})):r.createElement(h,o({ref:t},u))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var c=2;c<i;c++)o[c]=n[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},3463:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var r=n(7462),a=(n(7294),n(3905));const i={},o="6. Concurrency",l={unversionedId:"Year2/2007/6",id:"Year2/2007/6",title:"6. Concurrency",description:"17/10/22",source:"@site/docs/Year2/2007/6.md",sourceDirName:"Year2/2007",slug:"/Year2/2007/6",permalink:"/Year2/2007/6",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"year2",previous:{title:"5. Process Scheduling",permalink:"/Year2/2007/5"},next:{title:"7. Concurrency (2)",permalink:"/Year2/2007/7"}},s={},c=[{value:"Concurrency",id:"concurrency",level:2},{value:"Race Conditions",id:"race-conditions",level:2},{value:"Concurrency within the OS",id:"concurrency-within-the-os",level:2},{value:"Data Structures",id:"data-structures",level:3},{value:"Resources",id:"resources",level:3},{value:"Critical Sections, Mutual Exclusion",id:"critical-sections-mutual-exclusion",level:2},{value:"Enforcing Mutual Exclusion",id:"enforcing-mutual-exclusion",level:3},{value:"Deadlocks",id:"deadlocks",level:2}],u={toc:c};function p(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"6-concurrency"},"6. Concurrency"),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},"17/10/22")),(0,a.kt)("h2",{id:"concurrency"},"Concurrency"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Threads/processes execute concurrently and can share resources. (Multi-program mining improves system utilisation)"),(0,a.kt)("li",{parentName:"ul"},"A thread/process can be interrupted at any point in time. Process state is saved in the process control block"),(0,a.kt)("li",{parentName:"ul"},"Outcome of programs may become unpredictable. Sharing data can lead to inconsistencies, outcome of execution may depend on the order in which instructions are carried out.")),(0,a.kt)("p",null,"Not always in order. Registers can sometimes not sequentially execute code in the correct order."),(0,a.kt)("h2",{id:"race-conditions"},"Race Conditions"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"A race condition occurs when multiple threads/processes access shared data and the result is dependent on the order in which the instructions are interleaved. "),(0,a.kt)("li",{parentName:"ul"},"Mechanisms to provide controlled/synchronised access to data and avoid race conditions"),(0,a.kt)("li",{parentName:"ul"},"What comes out is dependent on the order they are carried out/interleaved ")),(0,a.kt)("h2",{id:"concurrency-within-the-os"},"Concurrency within the OS"),(0,a.kt)("h3",{id:"data-structures"},"Data Structures"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Kernels are preemptive these days. (Multiple processes/threads are running in the kernel. These cannot be interrupted any any point)"),(0,a.kt)("li",{parentName:"ul"},"The kernel maintains data structures",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Accessed concurrently/in parallel"),(0,a.kt)("li",{parentName:"ul"},"Can be subject to concurrency issues"))),(0,a.kt)("li",{parentName:"ul"},"OS must make sure that interactions within the OS do not result in rare conditions")),(0,a.kt)("h3",{id:"resources"},"Resources"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Processes share resources, including memory, files etc."),(0,a.kt)("li",{parentName:"ul"},"Operating system must:",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Provide locking mechanisms to implement/support mutual exclusions and prevent starvation/deadlocks"),(0,a.kt)("li",{parentName:"ul"},"Allocate and de-allocate these resources safely")))),(0,a.kt)("h2",{id:"critical-sections-mutual-exclusion"},"Critical Sections, Mutual Exclusion"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Critical Section"),": set of instructions in which shared resources between processes/threads are changed. Only 1 thing can access it at once. Manipulating that share across multiple users. This section gets locked whilst something is accessing it."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Mutual Exclusion"),": must be enforced for critical sections. ",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Only one process at a time should be in the critical section"),(0,a.kt)("li",{parentName:"ul"},'Processes have to get "permission" before entering their critical section'))),(0,a.kt)("li",{parentName:"ul"},"Any solution to the critical section problem must satisfy the following requirements:\\",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Mutual exclusion"),": only one process can be in its critical section at any one point in time"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Progress"),": any process must be able to enter its critical section at some point in time"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Fairness/bounded waiting"),'"": fairly distributed waiting times/processes cannot be made to wait indefinitely.'))),(0,a.kt)("li",{parentName:"ul"},"Requirements have to be satisfied, independent of the order in which sequences are executed.")),(0,a.kt)("h3",{id:"enforcing-mutual-exclusion"},"Enforcing Mutual Exclusion"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Bottom line of the OS is to hide away the complexity of the hardware."),(0,a.kt)("li",{parentName:"ul"},"Approaches for mutual exclusion can be:",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Software based: Peterson's solution"),(0,a.kt)("li",{parentName:"ul"},"Hardware based: ",(0,a.kt)("inlineCode",{parentName:"li"},"test_and_set()"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"swap_and_compare()")),(0,a.kt)("li",{parentName:"ul"},"Based on:",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Mutexes/Semaphones"))),(0,a.kt)("li",{parentName:"ul"},"Monitors (software construct within the programming languages)"))),(0,a.kt)("li",{parentName:"ul"},"Deadlocks have to be prevented")),(0,a.kt)("h2",{id:"deadlocks"},"Deadlocks"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Set of processes/threads is deadlocked if each process/thread in the set is waiting for an event that only the other process/thread in the set can cause")),(0,a.kt)("p",null,"Working with mutexes cause deadlocks"),(0,a.kt)("p",null,"Four conditions must hold for deadlocks to occur:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Mutual exclusion"),": a resource can be assigned to at most one process at a time"),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Hold and wait condition"),": a resource can be held whilst requesting new resources"),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"No preemption"),": resources cannot be forcefully taken away from a process"),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Circular wait"),": there is a circular chain of two or more processes, waiting for a resource held by the other processes.")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"No deadlocks can occur if one of the conditions is not satisfied.")))}p.isMDXComponent=!0}}]);