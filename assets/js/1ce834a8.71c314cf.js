"use strict";(self.webpackChunknottes=self.webpackChunknottes||[]).push([[1621],{3905:(e,t,i)=>{i.d(t,{Zo:()=>c,kt:()=>h});var a=i(67294);function n(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}function l(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,a)}return i}function o(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?l(Object(i),!0).forEach((function(t){n(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):l(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}function r(e,t){if(null==e)return{};var i,a,n=function(e,t){if(null==e)return{};var i,a,n={},l=Object.keys(e);for(a=0;a<l.length;a++)i=l[a],t.indexOf(i)>=0||(n[i]=e[i]);return n}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)i=l[a],t.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(e,i)&&(n[i]=e[i])}return n}var s=a.createContext({}),u=function(e){var t=a.useContext(s),i=t;return e&&(i="function"==typeof e?e(t):o(o({},t),e)),i},c=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var i=e.components,n=e.mdxType,l=e.originalType,s=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),p=u(i),h=n,m=p["".concat(s,".").concat(h)]||p[h]||d[h]||l;return i?a.createElement(m,o(o({ref:t},c),{},{components:i})):a.createElement(m,o({ref:t},c))}));function h(e,t){var i=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var l=i.length,o=new Array(l);o[0]=p;var r={};for(var s in t)hasOwnProperty.call(t,s)&&(r[s]=t[s]);r.originalType=e,r.mdxType="string"==typeof e?e:n,o[1]=r;for(var u=2;u<l;u++)o[u]=i[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,i)}p.displayName="MDXCreateElement"},14404:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>d,frontMatter:()=>l,metadata:()=>r,toc:()=>u});var a=i(87462),n=(i(67294),i(3905));const l={},o="26. Exam Practise Questions",r={unversionedId:"Year2/2007/26",id:"Year2/2007/26",title:"26. Exam Practise Questions",description:"Lecture 10",source:"@site/docs/Year2/2007/26.md",sourceDirName:"Year2/2007",slug:"/Year2/2007/26",permalink:"/Year2/2007/26",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"year2",previous:{title:"25. Revision",permalink:"/Year2/2007/25"},next:{title:"Introduction to Algorithms Data structures & Efficiency",permalink:"/Year2/2009/ADE/00"}},s={},u=[{value:"Lecture 10",id:"lecture-10",level:2},{value:"Lecture 11",id:"lecture-11",level:2},{value:"Lecture 14",id:"lecture-14",level:2},{value:"Lecture 15",id:"lecture-15",level:2},{value:"Lecture 16",id:"lecture-16",level:2},{value:"Lecture 17",id:"lecture-17",level:2},{value:"Hard Disk Example Questions",id:"hard-disk-example-questions",level:2},{value:"Lecture 19",id:"lecture-19",level:2},{value:"Lecture 21",id:"lecture-21",level:2},{value:"Lecture 22",id:"lecture-22",level:2},{value:"Lecture 23",id:"lecture-23",level:2},{value:"Lecture 24",id:"lecture-24",level:2},{value:"Question 1",id:"question-1",level:2},{value:"a.",id:"a",level:3},{value:"b.",id:"b",level:3},{value:"c.",id:"c",level:3},{value:"d.",id:"d",level:3},{value:"e.",id:"e",level:3},{value:"f.",id:"f",level:3},{value:"i.",id:"i",level:4},{value:"ii.",id:"ii",level:4},{value:"iii.",id:"iii",level:4},{value:"Question 2",id:"question-2",level:2},{value:"a.",id:"a-1",level:3},{value:"b.",id:"b-1",level:3},{value:"c.",id:"c-1",level:3},{value:"d.",id:"d-1",level:3},{value:"e.",id:"e-1",level:3},{value:"f.",id:"f-1",level:3},{value:"Question 3",id:"question-3",level:2},{value:"a.",id:"a-2",level:3},{value:"b.",id:"b-2",level:3},{value:"c.",id:"c-2",level:3},{value:"d.",id:"d-2",level:3},{value:"e.",id:"e-2",level:3},{value:"f.",id:"f-2",level:3},{value:"Question 4",id:"question-4",level:2},{value:"a.",id:"a-3",level:3},{value:"b",id:"b-3",level:3},{value:"c.",id:"c-3",level:3},{value:"d.",id:"d-3",level:3},{value:"e.",id:"e-3",level:3},{value:"f.",id:"f-3",level:3},{value:"g.",id:"g",level:3}],c={toc:u};function d(e){let{components:t,...l}=e;return(0,n.kt)("wrapper",(0,a.Z)({},c,l,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"26-exam-practise-questions"},"26. Exam Practise Questions"),(0,n.kt)("h2",{id:"lecture-10"},"Lecture 10"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Mutexes in some operating systems will put the tread to sleep after it has been spinning for a while? why?"),(0,n.kt)("li",{parentName:"ul"},"Does one need mututal exclusion when using user threads?"),(0,n.kt)("li",{parentName:"ul"},"Does the implementation with counting semaphores work for a single producer and single consumer (bounded/unbounded)")),(0,n.kt)("h2",{id:"lecture-11"},"Lecture 11"),(0,n.kt)("blockquote",null,(0,n.kt)("p",{parentName:"blockquote"},"Can I initialise the value of the ",(0,n.kt)("inlineCode",{parentName:"p"},"eating")," semaphore to 2 to create maximum parallelism"),(0,n.kt)("ul",{parentName:"blockquote"},(0,n.kt)("li",{parentName:"ul"},"Would it deadlock?"),(0,n.kt)("li",{parentName:"ul"},"Do we get maximum parallelism?"))),(0,n.kt)("h2",{id:"lecture-14"},"Lecture 14"),(0,n.kt)("blockquote",null,(0,n.kt)("p",{parentName:"blockquote"},"Compare the storage needed to keep track of free memory using bitmap vs. linked list with a main memory of 8 gygabytes, and a block size of 1 megabyte. For the linked list, assume that exactly half of the memory is in use, and that memory contains an alternating sequence of occupied blocks and free blocks. We will only keep track of free blocks with this list, assuming that each node needs a 32-bit memory address, a 16-bit length, and a 16-bit next-node field.")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"How many bytes of storage are required for each method?")),(0,n.kt)("h2",{id:"lecture-15"},"Lecture 15"),(0,n.kt)("blockquote",null,(0,n.kt)("p",{parentName:"blockquote"},"Given a 64-bit machine that uses paging, and a page/frame size of 4096 bytes")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"What would be the maximum number of frames?\nHint: First compute the maximum number of bytes you can address with a 64-bit machine")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"How many pages do we have in a 17 kilobytes process? How much\nmemory are we wasting in the last partition?"))),(0,n.kt)("h2",{id:"lecture-16"},"Lecture 16"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Given a 4KB page/frame size, and a 16-bit address space, calculate:",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"Number M of bits for offset within a page."),(0,n.kt)("li",{parentName:"ul"},"Number N of bits for representing pages. So, number of pages?"))),(0,n.kt)("li",{parentName:"ul"},"What is the physical address for 0, 8192, 20500 using this page table?")),(0,n.kt)("p",null,(0,n.kt)("img",{src:i(43243).Z,width:"260",height:"355"})),(0,n.kt)("h2",{id:"lecture-17"},"Lecture 17"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Compare FIFO with the optimal page replacement algorithm. The process starts up with none of its pages in memory."),(0,n.kt)("li",{parentName:"ul"},"What would be the minimum number of page faults that would be generated by the optimal approach?\n",(0,n.kt)("img",{src:i(44068).Z,width:"667",height:"277"}))),(0,n.kt)("h2",{id:"hard-disk-example-questions"},"Hard Disk Example Questions"),(0,n.kt)("p",null,(0,n.kt)("img",{src:i(92025).Z,width:"895",height:"428"}),"\n",(0,n.kt)("img",{src:i(32407).Z,width:"895",height:"428"}),"\n",(0,n.kt)("img",{src:i(83262).Z,width:"895",height:"254"})),(0,n.kt)("h2",{id:"lecture-19"},"Lecture 19"),(0,n.kt)("blockquote",null,(0,n.kt)("p",{parentName:"blockquote"},"Disk requests come in to the disk driver for cylinders 10, 22, 20, 2, 40, 6 and 38, in that order. A seek takes 6ms per cylinder."),(0,n.kt)("ul",{parentName:"blockquote"},(0,n.kt)("li",{parentName:"ul"},"How much seek time is needed for: FCFS, SSTF and Look-SCAN (initially moving upward)"),(0,n.kt)("li",{parentName:"ul"},"In all cases, the arm is initially at cylinder 20."))),(0,n.kt)("h2",{id:"lecture-21"},"Lecture 21"),(0,n.kt)("blockquote",null,(0,n.kt)("p",{parentName:"blockquote"},"We have seen that with i-nodes, the maximum file size that we can have depends on the block size and the number of indirections.")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Assuming a 32-bit disk address space, what would be the maximum (theoretical) file size for the FAT file system with a drive of 500GB and a block size of 1KB? (without accounting for directory metadata)"),(0,n.kt)("li",{parentName:"ul"},"The most used implementation of FAT is known as FAT-32. Investigate why there is a theoretical limitation of 4GB per file (and sometimes even less than 2GB).")),(0,n.kt)("h2",{id:"lecture-22"},"Lecture 22"),(0,n.kt)("blockquote",null,(0,n.kt)("p",{parentName:"blockquote"},"Following up the previous question on FAT-32, we mentioned that FAT-32 has severe limitations (e.g. the file allocation table could be too big).")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Why do you think that this file system is still in use in most of flash drives, cameras or MP3 players?"),(0,n.kt)("li",{parentName:"ul"},"When would you consider formatting your flash drive with NTFS or ext3? "),(0,n.kt)("li",{parentName:"ul"},"If you format your flash drive with (Windows) NTFS, will it work (directly) in Unix systems?")),(0,n.kt)("h2",{id:"lecture-23"},"Lecture 23"),(0,n.kt)("p",null,"Exercise 1: Using the ext2 file system (i.e. 12 direct block addresses are\ncontained in the i-node, and up to triple indirect), and assuming a block\nsize of 4 kilobytes, and a 32-bits disk address space."),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Could we store a file of 18 gigabytes?"),(0,n.kt)("li",{parentName:"ul"},"How many disk blocks we spend for the i-node of a file of 16 megabytes?\nExercise 2: In Linux, how many lookups are necessary to find (and load)\nthe file: /opt/spark/bin/spark-shell?")),(0,n.kt)("p",null,"Ex 1 a"),(0,n.kt)("blockquote",null,(0,n.kt)("p",{parentName:"blockquote"},"! We have blocks of 4 kilobytes, and we need 32 bits (4 bytes) to represent a disk address \u21d2 in one single block, we could store up to 1024 block pointers:\n4KB = 4",(0,n.kt)("em",{parentName:"p"},"210 / 4 bytes each = 210 = 1024 block pointers.\nUsing the 12 direct block pointers, we could have a file of with 12 blocks.\nUsing the single indirect: 1024 extra block pointers.\nUsing the double indirect: 1024"),"1024 block pointers (1048576).\nUsing the triple indirect, 1024",(0,n.kt)("em",{parentName:"p"},"1024"),"1024 block pointers (1073741824).\nIf we aggregate all of them => 1,074,791,436 blocks of 4KBs which is approx 4TB")),(0,n.kt)("p",null,"Ex 1 a"),(0,n.kt)("blockquote",null,(0,n.kt)("p",{parentName:"blockquote"},"For a file of 16 megabytes, we need: 16",(0,n.kt)("em",{parentName:"p"},"220/4"),"210 = 212 = 4096 blocks\npointers!\nWe will use fully all direct block pointers (12) ","[1 block]","\nWith the single indirect we have 1024 extra block pointers ","[1 block]","\nWith the double indirect we can address 1048576 block pointer... so we\nwon\u2019t go further than this level.\nWith direct pointer and single indirect we have covered 1024+12 block\npointers... we still need 3060\nEach block will handle 1024 pointers. So, 3060/1024 = 2.9882\nWe need three blocks + the \u201cfirst level\u201d block.\nTotal: 6 blocks of 4 kilobytes => 24KB")),(0,n.kt)("p",null,(0,n.kt)("img",{src:i(34709).Z,width:"895",height:"516"})),(0,n.kt)("h2",{id:"lecture-24"},"Lecture 24"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Why do type 2 hypervisors exist? After all, there is nothing they can do that type 1 hypervisors cannot do and the type 1 hypervisors are generally more efficient as well."),(0,n.kt)("li",{parentName:"ul"},"Can a virtualised OS (e.g. Cent OS 7) use a paging system with virtual\nmemory to manage its own memory? If yes, will this be using TLBs?")),(0,n.kt)("hr",null),(0,n.kt)("h1",{id:"exam-paper"},"Exam Paper"),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://moodle.nottingham.ac.uk/pluginfile.php/8536446/mod_resource/content/1/G52OSC15-16.pdf"},"Accessible Here")),(0,n.kt)("h2",{id:"question-1"},"Question 1"),(0,n.kt)("h3",{id:"a"},"a."),(0,n.kt)("p",null,"New - Process has just began and waiting to be admitted. -> ready, when to admit process to the system\nReady - process is waiting for the cpu to become available. -> running, decide which process to run next\nRunning - process owns the CPU -> ready, when to interrupt process, -> Blocked, waiting for io, -> exit, finished executing\nBlocked - process cannot continue, could be waiting for IO -> ready, when process has finished waiting/can continue\nExit - Process is no longer executable"),(0,n.kt)("h3",{id:"b"},"b."),(0,n.kt)("p",null,"Necessary for context switching in multi-programmed systems. Changes the state of the current process, either from running, ready, suspended etc. Would expect it to handle interrupts, and multi tasking, ensuring one process is not hogging the CPU. This cannot be accessed directly, more so through system calls, at user level, so it cant be abused or cause issues within the os. Only kernel mode can access it."),(0,n.kt)("h3",{id:"c"},"c."),(0,n.kt)("h3",{id:"d"},"d."),(0,n.kt)("p",null,"Kernel level threads will be quicker as that can achieve true parallelism, unlike user level which cannot. With user level, once it becomes deadlock, the entire process is. With kernel level, if one gets deadlock, the others can still run, and the workload can be divided between them."),(0,n.kt)("h3",{id:"e"},"e."),(0,n.kt)("p",null,"You would get 3 childs because the child process still executes the forloop. This can be fixed by having an ",(0,n.kt)("inlineCode",{parentName:"p"},"exit")," or ",(0,n.kt)("inlineCode",{parentName:"p"},"break")," statement in the child condition where ",(0,n.kt)("inlineCode",{parentName:"p"},"else if(pid==0)")),(0,n.kt)("h3",{id:"f"},"f."),(0,n.kt)("h4",{id:"i"},"i."),(0,n.kt)("p",null,"Priority Queue -\nProcess C, complete (15)\nProcess D, wait 15, 15, 5, complete (35)\nProcess B, wait 35, 15, wait 15, 15, wait 15, 5 (100)\nProcess A, wait 50, 15, wait 15, 15, wait 5, 15, 5 (120)\nShortest Job First Queue\nC,D,B,A"),(0,n.kt)("h4",{id:"ii"},"ii."),(0,n.kt)("p",null,"Avg response: 25ms"),(0,n.kt)("h4",{id:"iii"},"iii."),(0,n.kt)("p",null,"Avg turnaround: 68ms"),(0,n.kt)("h2",{id:"question-2"},"Question 2"),(0,n.kt)("h3",{id:"a-1"},"a."),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Mono-programming + process always allocated the entire memory space - has direct access to physical memory, which means OS"),(0,n.kt)("li",{parentName:"ul"},"Fixed partitions with equal size + reduces internal fragmentation - result into starvation"),(0,n.kt)("li",{parentName:"ul"},"Dynamic Partitions + processes are allocated the exact amount of contiguous memory it requires - external fragmentation"),(0,n.kt)("li",{parentName:"ul"},"Paging + no external fragmentation - bigger it gets, the slower it gets"),(0,n.kt)("li",{parentName:"ul"},"Virtual memory with paging + all pages loaded into memory which reduces page fault rates - ?")),(0,n.kt)("h3",{id:"b-1"},"b."),(0,n.kt)("p",null,"Mutual exclusion - only one process can be in its critical section at one time\nProgress - any process must be able to enter its critical section at some point in time\nFairness/bounded waiting - fairly distributed waiting times, cannot wait indefinitely."),(0,n.kt)("h3",{id:"c-1"},"c."),(0,n.kt)("p",null,"Best would be a mutex as they are more efficient than a semaphore on a multi-core machine. Furthermore the mutex and be implemented like a semaphore. With a normal semaphore, a thread can experience starvation/deadlocks depending on the implementation of the system due to poor LIFO."),(0,n.kt)("h3",{id:"d-1"},"d."),(0,n.kt)("p",null,"i. High priority process can wait for a resource which is held by a lower priority process\nii. ?\niii. ?\niv. ?"),(0,n.kt)("h3",{id:"e-1"},"e."),(0,n.kt)("p",null,"The output printed will be 0, due each child having a local/individual version of the iCounter. Only the parent process outputs the iCounter, and due to it not changing, It'll still be 0."),(0,n.kt)("h3",{id:"f-1"},"f."),(0,n.kt)("p",null,"?"),(0,n.kt)("h2",{id:"question-3"},"Question 3"),(0,n.kt)("h3",{id:"a-2"},"a."),(0,n.kt)("p",null,"When program is first run, wont know in advance which partitions/addresses it will occupy. Program addresses should be relative to where the process has been located. Is important nowadays due to multi-core/threading systems dynamically switch between programs, its necessary to relocate objects. ??"),(0,n.kt)("h3",{id:"b-2"},"b."),(0,n.kt)("p",null,"Mutual exclusion - resource assigned to one process\nHold and wait condition - held whilst requesting new resource\nNo preemption - resource cannot be forcefully taken away from a process\nCircular wait - circular chain of process waiting for a resource held by another resource.\n???"),(0,n.kt)("h3",{id:"c-2"},"c."),(0,n.kt)("p",null,"??"),(0,n.kt)("h3",{id:"d-2"},"d."),(0,n.kt)("h3",{id:"e-2"},"e."),(0,n.kt)("p",null,"Not on spec"),(0,n.kt)("h3",{id:"f-2"},"f."),(0,n.kt)("p",null,"first fit - b, a, e\nnext fit - b,c, e or rest of c and d\nbest fit - b, f, e"),(0,n.kt)("h2",{id:"question-4"},"Question 4"),(0,n.kt)("h3",{id:"a-3"},"a."),(0,n.kt)("p",null,"Thrashing is when pages are swapped out and loaded again immediately. Possible causes are when the degree of multi-programming is too high. Can be prevented by good page replacement policies or by adding more memory."),(0,n.kt)("h3",{id:"b-3"},"b"),(0,n.kt)("p",null,"Contiguous  + Simple to implement, only location of first block and length is required. - Exact size of file beforehand is not always known\nLinked list + file sizes can grow dynamically, new blocks can be added to the end of the file - Space is lost within the blocks due to the pointer\nFat + no space is lost due to the pointer - size of the allocation table grows with the number of blocks\ni-nodes + greatly increases disk performance on writes, file creates etc - Not been widely used because it is highly incompatible with existing file systems"),(0,n.kt)("h3",{id:"c-3"},"c."),(0,n.kt)("p",null,"Ext3/4 implement journaling. It also allowed for increased filenames and sizes, which improved directory implementation. They are also a lot more reliable compared to i-nodes as it would reduce fragmentation by storing i-nodes, files and parent directories in the same block group if possible. Also meant it was quicker to access. "),(0,n.kt)("h3",{id:"d-3"},"d."),(0,n.kt)("p",null,(0,n.kt)("em",{parentName:"p"},"yet to lean")),(0,n.kt)("h3",{id:"e-3"},"e."),(0,n.kt)("h3",{id:"f-3"},"f."),(0,n.kt)("h3",{id:"g"},"g."),(0,n.kt)("p",null,"230"))}d.isMDXComponent=!0},43243:(e,t,i)=>{i.d(t,{Z:()=>a});const a=i.p+"assets/images/20230121164425-1e2d472e5e7343c446435922fccf64be.png"},44068:(e,t,i)=>{i.d(t,{Z:()=>a});const a=i.p+"assets/images/20230121164554-7ac0b0e26a471dd07f2b61a289b35312.png"},92025:(e,t,i)=>{i.d(t,{Z:()=>a});const a=i.p+"assets/images/20230121164726-41f9886b403600ee70e5bdf866530f34.png"},32407:(e,t,i)=>{i.d(t,{Z:()=>a});const a=i.p+"assets/images/20230121164746-26759a20f2c5485d399d30a41cf8fe68.png"},83262:(e,t,i)=>{i.d(t,{Z:()=>a});const a=i.p+"assets/images/20230121164802-01a43857740e3aa4bb00280d813b3256.png"},34709:(e,t,i)=>{i.d(t,{Z:()=>a});const a=i.p+"assets/images/20230121165439-7383c80e102b95d57942fc4947c0029c.png"}}]);