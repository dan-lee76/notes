"use strict";(self.webpackChunknottes=self.webpackChunknottes||[]).push([[8585],{3905:(e,t,a)=>{a.d(t,{Zo:()=>m,kt:()=>d});var r=a(7294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},i=Object.keys(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var s=r.createContext({}),p=function(e){var t=r.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},m=function(e){var t=p(e.components);return r.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,i=e.originalType,s=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),u=p(a),d=n,h=u["".concat(s,".").concat(d)]||u[d]||c[d]||i;return a?r.createElement(h,l(l({ref:t},m),{},{components:a})):r.createElement(h,l({ref:t},m))}));function d(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=a.length,l=new Array(i);l[0]=u;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:n,l[1]=o;for(var p=2;p<i;p++)l[p]=a[p];return r.createElement.apply(null,l)}return r.createElement.apply(null,a)}u.displayName="MDXCreateElement"},8675:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>c,frontMatter:()=>i,metadata:()=>o,toc:()=>p});var r=a(7462),n=(a(7294),a(3905));const i={},l="13. Memory Management 2",o={unversionedId:"Year2/2007/13",id:"Year2/2007/13",title:"13. Memory Management 2",description:"04/11/22",source:"@site/docs/Year2/2007/13.md",sourceDirName:"Year2/2007",slug:"/Year2/2007/13",permalink:"/Year2/2007/13",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"year2",previous:{title:"12. Memory Management",permalink:"/Year2/2007/12"},next:{title:"0. Introduction to Algorithms Correctness and Efficiency",permalink:"/Year2/2009/00"}},s={},p=[{value:"Relocation and Protection",id:"relocation-and-protection",level:2},{value:"Principles",id:"principles",level:3},{value:"Address Types",id:"address-types",level:3},{value:"Approaches",id:"approaches",level:3},{value:"Base and Limit Registers",id:"base-and-limit-registers",level:3},{value:"Dynamic Partitioning",id:"dynamic-partitioning",level:2},{value:"Swapping",id:"swapping",level:3},{value:"Difficulties",id:"difficulties",level:3},{value:"Allocation Structures",id:"allocation-structures",level:3},{value:"Bitmaps",id:"bitmaps",level:4},{value:"Linked List",id:"linked-list",level:4}],m={toc:p};function c(e){let{components:t,...i}=e;return(0,n.kt)("wrapper",(0,r.Z)({},m,i,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"13-memory-management-2"},"13. Memory Management 2"),(0,n.kt)("p",null,(0,n.kt)("em",{parentName:"p"},"04/11/22")),(0,n.kt)("h2",{id:"relocation-and-protection"},"Relocation and Protection"),(0,n.kt)("h3",{id:"principles"},"Principles"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Relocation: when a program is run, it does not know in advance which partition/addresses it will occupy",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"The program cannot simply generate static addresses that are absolute"),(0,n.kt)("li",{parentName:"ul"},"Addresses should be relative to where the process has been loaded"),(0,n.kt)("li",{parentName:"ul"},"Relocation must be solved in an operating system that allows process to run a changing memory locations"))),(0,n.kt)("li",{parentName:"ul"},"Protection: once you can have two programs in memory at the same time, protection must be enforced")),(0,n.kt)("h3",{id:"address-types"},"Address Types"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"A logical address is a memory address seen by the process",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"It is independent of the current physical memory assignment"),(0,n.kt)("li",{parentName:"ul"},"Its relative to the start of the program"))),(0,n.kt)("li",{parentName:"ul"},"Physical address refers to an actual location in main memory"),(0,n.kt)("li",{parentName:"ul"},"The logical address space must be mapped onto the machines physical address space")),(0,n.kt)("h3",{id:"approaches"},"Approaches"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"Static 'relocation' at compile time: a process has to be located at the same location every single time"),(0,n.kt)("li",{parentName:"ol"},"Dynamic relocation at load time",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"Offset is added to every logical address to account for its physical location in memory"),(0,n.kt)("li",{parentName:"ul"},"Slows down the loading of a process, does not account for swapping"))),(0,n.kt)("li",{parentName:"ol"},"Dynamic relocation at runtime")),(0,n.kt)("h3",{id:"base-and-limit-registers"},"Base and Limit Registers"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Two special purpose registers are maintained in the CPU (the MMU), containing a base address and limit",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"The base register stores the start address of the partition"),(0,n.kt)("li",{parentName:"ul"},"The limit register holds the size of the partition"))),(0,n.kt)("li",{parentName:"ul"},"At runtime:",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"The base register is added to the logical(relative) address to generate the physical address"),(0,n.kt)("li",{parentName:"ul"},"The resulting address is compared against the limit register"))),(0,n.kt)("li",{parentName:"ul"},"This approach requires hardware support  (was not always present in the early days!)\n",(0,n.kt)("img",{src:a(6557).Z,width:"1043",height:"921"}))),(0,n.kt)("h2",{id:"dynamic-partitioning"},"Dynamic Partitioning"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Fixed partitioning results in internal fragmentation (inside the blocks)",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"An exact match between the requirements of the process and the available partitions may not exist"),(0,n.kt)("li",{parentName:"ul"},"The partition may not be used entirely"))),(0,n.kt)("li",{parentName:"ul"},"Dynamic partitioning",(0,n.kt)("pre",{parentName:"li"},(0,n.kt)("code",{parentName:"pre"},"- A variable number of partitions of which the size and starting address can change over time\n- A process is allocated the exact amount of contiguous memory it requires, thereby preventing internal fragmentation\n")),(0,n.kt)("img",{src:a(9981).Z,width:"1498",height:"778"}))),(0,n.kt)("h3",{id:"swapping"},"Swapping"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Swapping holds some of the process on the drive and shuttles processes between the drive and main memory as necessary"),(0,n.kt)("li",{parentName:"ul"},"Reasons for swapping:",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"Some processes only run occasionally"),(0,n.kt)("li",{parentName:"ul"},"Have more processes than partitions"),(0,n.kt)("li",{parentName:"ul"},"A process's memory requirements have changed"),(0,n.kt)("li",{parentName:"ul"},"The total amount of memory that is required for the process exceeds the available memory ")))),(0,n.kt)("h3",{id:"difficulties"},"Difficulties"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"The exact memory may not be known in advance (heat and stack grow dynamically)"),(0,n.kt)("li",{parentName:"ul"},"External fragmentation:",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"Swapping a process out of memory will create 'a hole'"),(0,n.kt)("li",{parentName:"ul"},"A new process may not use the entire 'hole', leaving a small unused block"),(0,n.kt)("li",{parentName:"ul"},"A new process may be too large for a given a 'hole'"))),(0,n.kt)("li",{parentName:"ul"},"The overhead of memory compaction to recover holes can be prohibitive and requires dynamic relocation ")),(0,n.kt)("h3",{id:"allocation-structures"},"Allocation Structures"),(0,n.kt)("h4",{id:"bitmaps"},"Bitmaps"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Simplest data structure that can be used in a form of bitmap"),(0,n.kt)("li",{parentName:"ul"},"Memory is split into blocks.(e.g 4kb size)"),(0,n.kt)("li",{parentName:"ul"},"To find a hole(128K) then a group of 32 adjacent bits set to 0 must be found, typically a long operation."),(0,n.kt)("li",{parentName:"ul"},"Trade-off exists between the size of the bitmap and the size of blocks exists",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"The size of bitmaps can become prohibitive for small blocks and may make searching the bitmap slower"),(0,n.kt)("li",{parentName:"ul"},"Larger blocks may increase internal fragmentation"))),(0,n.kt)("li",{parentName:"ul"},"Bitmaps are rarely used for this reason")),(0,n.kt)("h4",{id:"linked-list"},"Linked List"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"A more sophisticated data structure is required to deal with a variable number of free and used paritions"),(0,n.kt)("li",{parentName:"ul"})),(0,n.kt)("p",null,"Interal fragmentation - Inside the blocks\nExternal fragmentaiton - outside the block"))}c.isMDXComponent=!0},6557:(e,t,a)=>{a.d(t,{Z:()=>r});const r=a.p+"assets/images/Pasted image 20221104111004-bbf15f3a9a98fa9b1c6c2e7ca5610e61.png"},9981:(e,t,a)=>{a.d(t,{Z:()=>r});const r=a.p+"assets/images/Pasted image 20221104112610-c4b7e36472ef3f8a1be3818adf1bb031.png"}}]);