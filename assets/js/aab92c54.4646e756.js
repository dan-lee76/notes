"use strict";(self.webpackChunknottes=self.webpackChunknottes||[]).push([[7167],{3905:(e,n,r)=>{r.d(n,{Zo:()=>p,kt:()=>m});var t=r(67294);function l(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}function c(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),r.push.apply(r,t)}return r}function o(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?c(Object(r),!0).forEach((function(n){l(e,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):c(Object(r)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))}))}return e}function s(e,n){if(null==e)return{};var r,t,l=function(e,n){if(null==e)return{};var r,t,l={},c=Object.keys(e);for(t=0;t<c.length;t++)r=c[t],n.indexOf(r)>=0||(l[r]=e[r]);return l}(e,n);if(Object.getOwnPropertySymbols){var c=Object.getOwnPropertySymbols(e);for(t=0;t<c.length;t++)r=c[t],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(l[r]=e[r])}return l}var a=t.createContext({}),i=function(e){var n=t.useContext(a),r=n;return e&&(r="function"==typeof e?e(n):o(o({},n),e)),r},p=function(e){var n=i(e.components);return t.createElement(a.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},v=t.forwardRef((function(e,n){var r=e.components,l=e.mdxType,c=e.originalType,a=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),v=i(r),m=l,d=v["".concat(a,".").concat(m)]||v[m]||u[m]||c;return r?t.createElement(d,o(o({ref:n},p),{},{components:r})):t.createElement(d,o({ref:n},p))}));function m(e,n){var r=arguments,l=n&&n.mdxType;if("string"==typeof e||l){var c=r.length,o=new Array(c);o[0]=v;var s={};for(var a in n)hasOwnProperty.call(n,a)&&(s[a]=n[a]);s.originalType=e,s.mdxType="string"==typeof e?e:l,o[1]=s;for(var i=2;i<c;i++)o[i]=r[i];return t.createElement.apply(null,o)}return t.createElement.apply(null,r)}v.displayName="MDXCreateElement"},27395:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>u,frontMatter:()=>c,metadata:()=>s,toc:()=>i});var t=r(87462),l=(r(67294),r(3905));const c={},o="18. Compiler Correctness",s={unversionedId:"Year2/2009/IFR/18",id:"Year2/2009/IFR/18",title:"18. Compiler Correctness",description:"09/12/22",source:"@site/docs/Year2/2009/IFR/18.md",sourceDirName:"Year2/2009/IFR",slug:"/Year2/2009/IFR/18",permalink:"/Year2/2009/IFR/18",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"year2",previous:{title:"16. Permutation",permalink:"/Year2/2009/IFR/16"},next:{title:"Class Test Revision",permalink:"/Year2/2009/IFR/class_test"}},a={},i=[],p={toc:i};function u(e){let{components:n,...r}=e;return(0,l.kt)("wrapper",(0,t.Z)({},p,r,{components:n,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"18-compiler-correctness"},"18. Compiler Correctness"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"09/12/22")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lean"},'/- Lecture 19, IFR (COMP2009,2022-23) -/\nset_option pp.structure_projections false\nnamespace l19\ninductive Expr : Type \n| const : \u2115 \u2192 Expr\n| var : string \u2192 Expr\n| plus : Expr \u2192 Expr \u2192 Expr\n| times : Expr \u2192 Expr \u2192 Expr\n\nopen Expr\n\n--- x * (y + 2)\n\ndef e1 : Expr \n  := times (var "x") (plus (var "y") (const 2))\n\n-- (x * y) + 2\n\ndef e2 := plus (times (var "x") (var "y")) (const 2)\n\ntheorem no_conf : \u2200 n : \u2115, \u2200 l r : Expr, \n    const n \u2260 plus l r :=\nbegin \n  assume n l r h,\n  contradiction,\nend\n\ntheorem inj_plus_l : \u2200 l r l\' r\' : Expr , \n    plus l r = plus l\' r\' \u2192 l=l\' :=\nbegin\n  assume l r l\' r\' h,\n  injection h,\nend\n\n--#reduce e1\n\ndef Env : Type\n  := string \u2192 \u2115\n\ndef eval : Expr \u2192 Env \u2192 \u2115\n| (const n) env := n\n| (var s) env := env s\n| (plus l r) env := (eval l env) + (eval r env)\n| (times l r) env := (eval l env) * (eval r env)\n\ndef env0 : Env\n| "x" := 3\n| "y" := 5\n| _ := 0\n\n#reduce env0 "y"\n\n#reduce eval e1 env0\n\n#reduce eval e2 env0\n\ninductive Instr : Type\n| pushC : \u2115 \u2192 Instr\n| pushV : string \u2192 Instr\n| add : Instr\n| mult : Instr\n\nopen Instr\n\n@[reducible]\ndef Code : Type\n  := list Instr\n\ndef Stack : Type\n  := list \u2115\n\ndef run : Code \u2192 Stack \u2192 Env \u2192 \u2115 \n| [] [n] env := n\n| (pushC n ::c) s env := run c (n :: s) env\n| (pushV x ::c) s env := run c (env x :: s) env\n| (add :: c) (m :: n :: s) env := run c ((n + m) :: s) env\n| (mult :: c) (m :: n :: s) env := run c ((n * m) :: s) env\n| _ _ _ := 0\n\ndef c1 : Code\n:= [pushV "x",pushV "y",pushC 2,add,mult]\n\n#eval run c1 [] env0\n\nopen list\n\ndef compile0 : Expr \u2192 Code \n| (const n) := [pushC n]\n| (var x) := [pushV x]\n| (plus l r) := \n(compile0 l) ++ (compile0 r) ++ [add]\n| (times l r) := \n(compile0 l) ++ (compile0 r) ++ [mult]\n \n#reduce run (compile0 e1) [] env0\n\n#reduce run (compile0 e2) [] env0\n\ntheorem compile0_ok : \u2200 e : Expr, \u2200 env : Env,\n run (compile0 e) [] env = eval e env :=\nbegin\n  sorry\nend\n\n-- continuation passing compilation\ndef compile_aux : Expr \u2192 Code \u2192 Code \n| (const n) c := pushC n :: c\n| (var x) c := pushV x :: c\n| (plus l r) c := \ncompile_aux l (compile_aux r (add :: c))\n| (times l r) c := \ncompile_aux l (compile_aux r (mult :: c)) \n\ndef compile (e : Expr) : Code :=\n  compile_aux e []\n\n#reduce run (compile e1) [] env0\n\n#reduce run (compile e2) [] env0\n\nlemma compile_aux_lem :\n  \u2200 e : Expr, \u2200 c : Code, \u2200 s : Stack, \n  \u2200 env : Env,\n   run (compile_aux e c) s env =\n    run c (eval e env :: s) env :=\nbegin\n  assume e,\n  induction e,\n  case const : n {\n    assume c s env,\n    dsimp [compile_aux,eval,run],\n    reflexivity,},\n  case var : name {\n    assume c s env,\n    dsimp [compile_aux,eval,run],\n    reflexivity,},\n  case plus : l r ih_l ih_r {\n    assume c s env,\n    dsimp [compile_aux],\n    rewrite ih_l,\n    rewrite ih_r,\n    dsimp [eval,run],\n    reflexivity,\n  },\n  case times : l r ih_l ih_r {\n    assume c s env,\n    dsimp [compile_aux],\n    rewrite ih_l,\n    rewrite ih_r,\n    dsimp [eval,run],\n    reflexivity,\n  },\nend\n\ntheorem compile_ok : \u2200 e : Expr, \u2200 env : Env,\n run (compile e) [] env = eval e env :=\n-- run (compile e) [] env\n-- = run c (eval e env :: s) env\n-- = run (compile_aux e []) [] env\n-- = run [] (eval e env :: []) env\n-- = eval e env\nbegin\n  assume e env,\n  apply compile_aux_lem,\nend\n\n\nend l19\n')))}u.isMDXComponent=!0}}]);