"use strict";(self.webpackChunknottes=self.webpackChunknottes||[]).push([[514],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>c});var r=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=r.createContext({}),p=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=p(e.components);return r.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,s=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),d=p(n),c=i,h=d["".concat(s,".").concat(c)]||d[c]||m[c]||a;return n?r.createElement(h,l(l({ref:t},u),{},{components:n})):r.createElement(h,l({ref:t},u))}));function c(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,l=new Array(a);l[0]=d;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:i,l[1]=o;for(var p=2;p<a;p++)l[p]=n[p];return r.createElement.apply(null,l)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},2784:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>m,frontMatter:()=>a,metadata:()=>o,toc:()=>p});var r=n(7462),i=(n(7294),n(3905));const a={},l="10.   Parallel dining philosophers & Readers/writers problem",o={unversionedId:"Year2/2007/10",id:"Year2/2007/10",title:"10.   Parallel dining philosophers & Readers/writers problem",description:"The Dining Philosophers Problem - Continued",source:"@site/docs/Year2/2007/10.md",sourceDirName:"Year2/2007",slug:"/Year2/2007/10",permalink:"/Year2/2007/10",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"year2",previous:{title:"1. Introduction (2)",permalink:"/Year2/2007/1"},next:{title:"2. Processes",permalink:"/Year2/2007/2"}},s={},p=[{value:"The Dining Philosophers Problem - Continued",id:"the-dining-philosophers-problem---continued",level:2},{value:"Solution 3 - Maximum Parallelism",id:"solution-3---maximum-parallelism",level:3},{value:"The Reads - Writers Problem",id:"the-reads---writers-problem",level:2},{value:"Solution 1 - No Parallelism",id:"solution-1---no-parallelism",level:3},{value:"Solution 2 - Readers First",id:"solution-2---readers-first",level:3}],u={toc:p};function m(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,r.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"10---parallel-dining-philosophers--readerswriters-problem"},"10.   Parallel dining philosophers & Readers/writers problem"),(0,i.kt)("h2",{id:"the-dining-philosophers-problem---continued"},(0,i.kt)("a",{parentName:"h2",href:"/Year2/2007/9#The-Dining-Philosophers-Problem"},"The Dining Philosophers Problem - Continued")),(0,i.kt)("h3",{id:"solution-3---maximum-parallelism"},"Solution 3 - Maximum Parallelism"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A more sophisticated solution is necessary to allow maximum parallelism. "),(0,i.kt)("li",{parentName:"ul"},"The solution uses:",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"- `state[N]`: one state variable for every philosopher\n- `phil[N]`: one semaphore per philosopher (not forks, initialised to 0)\n    - Philosopher goes to sleep if neighbours are eating\n    - Neighbours wake up the philosopher if they finish eating\n- `sync`: one semaphore/mutex to enforce mutual exclusion of the critical section (while updating the states) \n")),"Needs to be done atomically all in one section")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'#define N 5\n#define THINKING 1\n#define HUNGRY 2\n#define EATING 3\n\nint state[N] = {THINKING, THINKING, THINKING, THINKING, THINKING};\nsem_t phil[N]; // sends philosopher to sleep\nsem_t sync;\n\nvoid * philosopher(void * id) {\n    int i = *((int *) id);\n    while(1) {\n        printf("%d is thinking\\n", i);\n        take_forks(i);\n        printf("%d is eating\\n", i);\n        put_forks(i);\n    }\n}\n\nvoid take_forks(int i) {\n    sem_wait(&sync);\n    state[i] = HUNGRY;\n    test(i);\n    sem_post(&sync);\n    sem_wait(&phil[i]);\n}\n\nvoid test(int i) {\n    int left = (i + N - 1) % N;\n    int right = (i + 1) % N;\n    if(state[i] == HUNGRY && state[left] != EATING && state[right] != EATING) {\n        state[i] = EATING;\n        sem_post(&phil[i]);\n    }\n}\n\nvoid put_forks(int i) {\n    int left = (i + N - 1) % N;\n    int right = (i + 1) % N;\n    sem_wait(&sync);\n    state[i] = THINKING;\n    test(left);\n    test(right);\n    sem_post(&sync);\n}\n')),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(3797).Z,width:"1558",height:"1022"})),(0,i.kt)("h2",{id:"the-reads---writers-problem"},"The Reads - Writers Problem"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Concurrent database processes are readers and/or writers, files, I/O devices etc"),(0,i.kt)("li",{parentName:"ul"},"Reading a record can happen in parallel without problems, writing needs synchronisation"),(0,i.kt)("li",{parentName:"ul"},"Different solutions:",(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},"Naive implementation with limited parallelism"),(0,i.kt)("li",{parentName:"ol"},"Readers receive priority: no reader is kept waiting (unless a writer already has access, writers may starve)"),(0,i.kt)("li",{parentName:"ol"},"Writing is performed as soon as possibly (readers may starve)")))),(0,i.kt)("h3",{id:"solution-1---no-parallelism"},"Solution 1 - No Parallelism"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'void * reader(void * arg) {\n    while(1) {\n        pthread_mutex_lock(&sync);\n        printf("reading record\\n");\n        pthread_mutex_unlock(&sync);\n    }\n}\n\nvoid * writer(void * writer) {\n    while(1) {\n        pthread_mutex_lock(&sync);\n        printf("writing\\n");\n        pthread_mutex_unlock(&sync);\n    }\n}\n')),(0,i.kt)("h3",{id:"solution-2---readers-first"},"Solution 2 - Readers First"),(0,i.kt)("p",null,"Allows parallel reading."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Implementation requires: "),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"iReadCount"),": integer tracking the number of readers"),(0,i.kt)("li",{parentName:"ul"},"if ",(0,i.kt)("inlineCode",{parentName:"li"},"iReadCount > 0")," writers are blocked (",(0,i.kt)("inlineCode",{parentName:"li"},"sem_wait(rSync)"),")"),(0,i.kt)("li",{parentName:"ul"},"if ",(0,i.kt)("inlineCode",{parentName:"li"},"iReadCount ==>== 0")," writers are released (",(0,i.kt)("inlineCode",{parentName:"li"},"sem_post(rwSync)"),")")),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(2636).Z,width:"1947",height:"959"})))}m.isMDXComponent=!0},3797:(e,t,n)=>{n.d(t,{Z:()=>r});const r=n.p+"assets/images/20221028102155-cd9ed2a64b7354c44b3ebfb58787eda6.png"},2636:(e,t,n)=>{n.d(t,{Z:()=>r});const r=n.p+"assets/images/20221028102358-4e88e07045981463d643fb6ca052128b.png"}}]);