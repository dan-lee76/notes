"use strict";(self.webpackChunknottes=self.webpackChunknottes||[]).push([[1102],{3905:(n,e,t)=>{t.d(e,{Zo:()=>s,kt:()=>p});var r=t(7294);function i(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function m(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function a(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?m(Object(t),!0).forEach((function(e){i(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):m(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function o(n,e){if(null==n)return{};var t,r,i=function(n,e){if(null==n)return{};var t,r,i={},m=Object.keys(n);for(r=0;r<m.length;r++)t=m[r],e.indexOf(t)>=0||(i[t]=n[t]);return i}(n,e);if(Object.getOwnPropertySymbols){var m=Object.getOwnPropertySymbols(n);for(r=0;r<m.length;r++)t=m[r],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(i[t]=n[t])}return i}var l=r.createContext({}),c=function(n){var e=r.useContext(l),t=e;return n&&(t="function"==typeof n?n(e):a(a({},e),n)),t},s=function(n){var e=c(n.components);return r.createElement(l.Provider,{value:e},n.children)},u={inlineCode:"code",wrapper:function(n){var e=n.children;return r.createElement(r.Fragment,{},e)}},d=r.forwardRef((function(n,e){var t=n.components,i=n.mdxType,m=n.originalType,l=n.parentName,s=o(n,["components","mdxType","originalType","parentName"]),d=c(t),p=i,y=d["".concat(l,".").concat(p)]||d[p]||u[p]||m;return t?r.createElement(y,a(a({ref:e},s),{},{components:t})):r.createElement(y,a({ref:e},s))}));function p(n,e){var t=arguments,i=e&&e.mdxType;if("string"==typeof n||i){var m=t.length,a=new Array(m);a[0]=d;var o={};for(var l in e)hasOwnProperty.call(e,l)&&(o[l]=e[l]);o.originalType=n,o.mdxType="string"==typeof n?n:i,a[1]=o;for(var c=2;c<m;c++)a[c]=t[c];return r.createElement.apply(null,a)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"},2207:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>m,metadata:()=>o,toc:()=>c});var r=t(7462),i=(t(7294),t(3905));const m={},a="11. Multiplicaiton & less-or-equal",o={unversionedId:"Year2/2009/11",id:"Year2/2009/11",title:"11. Multiplicaiton & less-or-equal",description:"11/11/22",source:"@site/docs/Year2/2009/11.md",sourceDirName:"Year2/2009",slug:"/Year2/2009/11",permalink:"/Year2/2009/11",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"year2",previous:{title:"10. Addition & commutative monoid",permalink:"/Year2/2009/10"},next:{title:"12. Deciding Equality of Natural Numbers (\u2115)",permalink:"/Year2/2009/12"}},l={},c=[],s={toc:c};function u(n){let{components:e,...t}=n;return(0,i.kt)("wrapper",(0,r.Z)({},s,t,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"11-multiplicaiton--less-or-equal"},"11. Multiplicaiton & less-or-equal"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"11/11/22")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lean"},"import tactic\nnamespace l12\nset_option pp.structure_projections false\nopen nat\n\ndef add : \u2115 \u2192 \u2115 \u2192 \u2115 \n| n zero := n \n| n (succ m) := succ (add n m)\n\n#reduce (add 7 3)\n\nlocal notation (name := add)\n  m + n := add m n\n\n#reduce (7 + 3)\n\ntheorem lneutr : \n  \u2200 n : \u2115, 0 + n = n :=\nbegin\n  assume n,\n  induction n with n' ih,\n    dsimp [(+)],\n    reflexivity,\n    dsimp [(+)],\n    rewrite ih,\nend\n\ntheorem rneutr : \n  \u2200 n : \u2115, n + 0 = n :=\nbegin\n  assume n,\n  dsimp [(+)],\n  reflexivity,\nend\n\ntheorem assoc : \u2200 l m n : \u2115,\n  (l+m)+n = l+(m+n) :=\nbegin\n  assume l m n,\n  induction n with n' ih,\n  -- (l+m)+0 = l+m\n  -- l+(m+0) = l+m\n  dsimp [(+)],\n  reflexivity,\n  -- (l+m)+succ n'\n  -- = succ ((l+m) + n')\n  -- l+(m+succ n')\n  -- = l+(succ (m + n'))\n  -- = succ (l+(m+n'))\n  dsimp [(+)],\n  rewrite ih,\nend\n\nlemma add_succ : \u2200 m n : \u2115,\n  (succ m) + n = succ (m + n) :=\nbegin\n  assume m n,\n  induction n with n' ih,\n  reflexivity,\n  dsimp [(+)],\n  rewrite ih,\nend\n\ntheorem comm : \u2200 m n : \u2115,\n  m+n = n+m :=\nbegin\n  assume m n,\n  induction n with n' ih,\n  dsimp [(+)],\n  rewrite lneutr,\n  calc\n    m+succ n' \n    = succ (m + n') : by reflexivity\n    ... = succ (n' + m) : by rewrite ih\n    ... = (succ n') + m : by rewrite add_succ\nend\n\ndef mult : \u2115 \u2192 \u2115 \u2192 \u2115\n| m zero := zero\n| m (succ n) := (mult m n) + m\n\nlocal notation (name := mult)\n  m * n := mult m n \n\n#eval 2*3\n\n-- (\u2115,*,1) is a commutative monoid\ntheorem mult_rneutr : \n  \u2200 n : \u2115, n * 1 = n :=\nbegin\n  sorry,\nend\n\ntheorem mult_lneutr : \n  \u2200 n : \u2115, 1 * n  = n :=\nbegin\n  sorry,\nend\n\ntheorem mult_assoc : \u2200 l m n : \u2115 , \n  (l * m) * n = l * (m * n) :=\nbegin\n  sorry,\nend\n\ntheorem mult_comm :  \u2200 m n : \u2115 ,\n  m * n = n * m :=\nbegin\n  sorry,\nend\n\n\n/-\nactually + and * interact nicely. \nWe have distributivity laws.\n\n-/\n\ntheorem mult_zero_l : \u2200 n : \u2115 , \n  0 * n = 0 :=\nbegin\n  sorry,\nend\n\ntheorem mult_zero_r : \u2200 n : \u2115 , \n  n * 0 = 0 :=\nbegin\n  sorry,\nend\n\ntheorem mult_distr_l :  \u2200 l m n : \u2115 , \n  (m + n) * l = m * l + n * l :=\nbegin\n  sorry,\nend\n\ntheorem mult_distr_r :  \u2200 l m n : \u2115 , \n  l * (m + n) = l * m + l * n :=\nbegin\n  sorry,\nend\n\n/-\n(\u2115,+,0,*,1) are a semi-ring\n(\u2124,+,0,minus,*,1) is a ring\n(\u211a,+,0,minus,*,1,1/..) is a field\na-b = a+minus b\na/b = a * 1/b\n-/\n\ndef le(m n : \u2115) : Prop \n:= \u2203 k : \u2115, k + m = n \n\nlocal notation (name := le)\n  m \u2264 n := le m n \n\nexample : 2 \u2264 3 :=\nbegin\n  dsimp [(\u2264)],\n  existsi 1,\n  reflexivity,\nend \n\nexample : \xac (3 \u2264 2) :=\nbegin\n  assume h,\n  dsimp [(\u2264)] at h,\n  cases h with k hh,\n  have h2 : k+2 = 1,\n  injection hh,\n  have h3:k+1 = 0,\n  injection h2,\n  contradiction,\nend\n\n-- \u2264 is a partial order\n-- preorder + antisymmetry\n-- reflexive : n \u2264 n\n-- transitive :\n--    m \u2264 n \u2192 n \u2264 l \u2192 m \u2264 l\n-- anti-symmetric :\n--    m \u2264 n \u2192 n \u2264 m \u2192 m = n\n\ntheorem le_refl : \u2200 n : \u2115, \n  n \u2264 n :=\nbegin\n  assume n,\n  dsimp [(\u2264)],\n  existsi 0,\n  apply lneutr,\nend \n\n\n\n\n\n\n\n\n\nend l12\n\ntheorem binom : \u2200 x y : \u2115, \n(x + y)^2 = x^2 + 2*x*y + y^2 :=\nbegin\n  assume x y,\n  ring,\nend \n\n#print binom\n")))}u.isMDXComponent=!0}}]);