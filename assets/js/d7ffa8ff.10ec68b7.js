"use strict";(self.webpackChunknottes=self.webpackChunknottes||[]).push([[889],{3905:function(e,t,a){a.d(t,{Zo:function(){return c},kt:function(){return h}});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),m=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},c=function(e){var t=m(e.components);return n.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=m(a),h=r,k=u["".concat(l,".").concat(h)]||u[h]||p[h]||i;return a?n.createElement(k,o(o({ref:t},c),{},{components:a})):n.createElement(k,o({ref:t},c))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,o=new Array(i);o[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var m=2;m<i;m++)o[m]=a[m];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},8230:function(e,t,a){a.r(t),a.d(t,{assets:function(){return c},contentTitle:function(){return l},default:function(){return h},frontMatter:function(){return s},metadata:function(){return m},toc:function(){return p}});var n=a(7462),r=a(3366),i=(a(7294),a(3905)),o=["components"],s={},l="Intro to OOP",m={unversionedId:"Year1/Programming Paradigms/Java/Revision",id:"Year1/Programming Paradigms/Java/Revision",title:"Intro to OOP",description:"- Benefits of OO: Improved understanding of program structure. Easy to re-use, adapt and/or modify existing work. Also ease to debug.",source:"@site/docs/Year1/1009 - Programming Paradigms/Java/Revision.md",sourceDirName:"Year1/1009 - Programming Paradigms/Java",slug:"/Year1/Programming Paradigms/Java/Revision",permalink:"/docs/Year1/Programming Paradigms/Java/Revision",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"22.03.31 - Design Patterns",permalink:"/docs/Year1/Programming Paradigms/Java/22.03.31 - Design Patterns"},next:{title:"0. Presentation of the Course",permalink:"/docs/Year1/Maths 2/22.02.02 - Introduction"}},c={},p=[{value:"Classes and Objects",id:"classes-and-objects",level:2},{value:"Exceptions",id:"exceptions",level:2},{value:"Object Lifetime",id:"object-lifetime",level:2},{value:"(Sub-type) Polymorphism and Interfaces",id:"sub-type-polymorphism-and-interfaces",level:2},{value:"Patterns",id:"patterns",level:2},{value:"Inner Classes",id:"inner-classes",level:2},{value:"Design Pattern Summary",id:"design-pattern-summary",level:2}],u={toc:p};function h(e){var t=e.components,s=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,n.Z)({},u,s,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"intro-to-oop"},"Intro to OOP"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Benefits of OO: Improved understanding of program structure. Easy to re-use, adapt and/or modify existing work. Also ease to debug."),(0,i.kt)("li",{parentName:"ul"},"Things will be in memory and will be able ot track itself. Objects have limits on what can change the data."),(0,i.kt)("li",{parentName:"ul"},"Can use OO features in other languages by faking them.")),(0,i.kt)("h2",{id:"classes-and-objects"},"Classes and Objects"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Class"),": A definition of a structure. Blueprint for creating an object. (What is in the object, what can you do to it)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Objects"),": Instances of the structure. Some collection of data that exists at runtime, which can apply functions to. One copy of data of that type for a specific thing. Can have multiple objects of the same class."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"public"),": Means anything can access it"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"private"),": means only the class members can access it")),(0,i.kt)("h1",{id:"using-objects"},"Using Objects"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Create main as the only static method in a class. "),(0,i.kt)("li",{parentName:"ul"},"Static is like a global functions which is callable anywhere. "),(0,i.kt)("li",{parentName:"ul"},"Using static, the code is not being executed on a specific object")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Java Conventions"),": Capital letter for class name. Lower case first letter for variable names and method/function names. Capitalise letter of subsequent words."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Objects"),":",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Use object references to refer to objects, similar to C pointers"),(0,i.kt)("li",{parentName:"ul"},"Use ",(0,i.kt)("inlineCode",{parentName:"li"},"new")," to create the object."),(0,i.kt)("li",{parentName:"ul"},"Assigning one reference to another refers to the same object"),(0,i.kt)("li",{parentName:"ul"},"Passing an object reference into a function refers to the same object"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"String"),": Dont need to create them, using ",(0,i.kt)("inlineCode",{parentName:"li"},"+")," will create a new string. Use ",(0,i.kt)("inlineCode",{parentName:"li"},"StringBuffer")," object if need to change a strings contents"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Autoboxing"),": Classes to wrap each of the basic data types. Can sometimes treat basic types as if they are objects"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Applying Functions"),": Expressed as ",(0,i.kt)("inlineCode",{parentName:"li"},"object.function()")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Decomposition"),": Reduces how much you have to consider at the same time. Procedural decomposition splits the program into a number of procedures/functions. The data ")),(0,i.kt)("h1",{id:"aggregation"},"Aggregation"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Constructors"),": Methods called to initialise new objects. A function which will automatically be called when the object is created. Has same name as the class."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Current Object Reference"),": Methods (non-static member functions) know which object they are acting on."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Static Members"),": Are not associated with any specific object"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ArrayList"),": Is a generic type, which is parameterised with another class. Has a ",(0,i.kt)("inlineCode",{parentName:"li"},"<type>")," added at the end of the name to say what it is. Behaviour must be the same regardless of the type of object. This is known as Parametric Polymorphic"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Abstraction"),": 'Hiding all but the information the user needs'. Don't need to know how the classes are implemented in order to use them."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Composition/Aggregation"),": Can be though of as one object containing another, or 'having' another. Both mean the object is composed of, or 'aggregates' other objects. Use them to reuse classes within other classes"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Aggregation"),": Items are contained in, or form a part of, the container item, but have a lifetime of their own"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Composition"),": The composed items only last as long as the containing item lasts, so they cease existing when container does.")),(0,i.kt)("h1",{id:"inheritance"},"Inheritance"),(0,i.kt)("p",null,"What OO people mean when they talk about polymorphism"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Inheritance"),": IS-A relationship. Can be specialisation of another class"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Polymorphism"),": Many forms, but not fixed to specific types"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Parametric Polymorphism"),": Code works with multiple types, or regardless of types."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Ad-hoc Polymorphism"),": Function overloading. Same function name, but multiple versions with different parameter types"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Sub-type Polymorphism"),": Sub-classing. What we mean by polymorphism in OO terms. Often called inheritance. ",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Original class is called 'super-class' or 'base class'"),(0,i.kt)("li",{parentName:"ul"},"New type is called a 'sub-class' or 'derived class'"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Private"),": Only this class can access this"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"nothing"),"(package): This class + this package can access this."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Protected"),": This class + this package + subclass can access this"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Public"),": Anything can access this")),(0,i.kt)("h1",{id:"class-diagrams"},"Class Diagrams"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"352f9b2d3f5195640e5c50f4dfe5fa0f.png",src:a(202).Z,width:"850",height:"499"})),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Aggregation (containment)"),": Is a specialised form of association. Defines ",(0,i.kt)("strong",{parentName:"li"},"one way relationship")," that specifies a ",(0,i.kt)("strong",{parentName:"li"},"'has-a'")," relationship between two classes"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Association"),": Indicates that a class knows about, and holds a reference to another class"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Composition"),": Way to combine objects or data types into more complex ones"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Class"),": Blueprints for objects. Has sub-classes of Object."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Objects"),": Classes specify the format of these")),(0,i.kt)("h2",{id:"exceptions"},"Exceptions"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Extra return value types to report exceptional events."),(0,i.kt)("li",{parentName:"ul"},"When exception is thrown, function will end unless caught"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Trowable"),": Can throw any Throwable object, not just an Exception object."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"RuntimeException"),": Common from many places and don't want to always check for them. Avoid throwing this, unless you don't want to force the caller to check for the exception."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Own Exceptions"),": Can throw your own. Create sub-class of ",(0,i.kt)("strong",{parentName:"li"},"Exception"),".")),(0,i.kt)("h2",{id:"object-lifetime"},"Object Lifetime"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"JVM is responsible for allocating the memory, freeing the memory."),(0,i.kt)("li",{parentName:"ul"},"Works out when objects no longer have object references to them"),(0,i.kt)("li",{parentName:"ul"},"Garbage Collection"),(0,i.kt)("li",{parentName:"ul"},"Set ",(0,i.kt)("inlineCode",{parentName:"li"},"br=null")," when no longer need the object")),(0,i.kt)("h1",{id:"swing-gui"},"Swing GUI"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Class Library"),": Can re-use existing classes to make our program."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Nouns"),": Help identify objects"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Verbs"),": Used to identify functionality"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ER Diagrams"),": Care about data, how to group it and how its related to other data. In OO class diagrams care about what is done and what is doing it."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Class Library use"),": Usually start by looking at what it can do and fit our plans around it")),(0,i.kt)("h1",{id:"layouts"},"Layouts"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Threads"),": When a window is created, a thread will be started, but ",(0,i.kt)("inlineCode",{parentName:"li"},"main()")," will remain running."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"JLabel"),": Can use the sub-class object as if it was the super-class. This overwrites sections, similar tpublic class Board\n{\nstatic Board theBoard;\nprivate Board() {}\nBoard get()\n{\nif (theBoard == null)\ntheBoard = new Board();\nreturn theBoard;\n}\n}o a theme."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"JPanel"),": Container for components. Set preferred size"),(0,i.kt)("li",{parentName:"ul"},"Have multiple layout (",(0,i.kt)("inlineCode",{parentName:"li"},"FlowLayout()"),",",(0,i.kt)("inlineCode",{parentName:"li"},"BorderLayout()"),",",(0,i.kt)("inlineCode",{parentName:"li"},"GridLayout()"),")")),(0,i.kt)("h1",{id:"interfaces"},"Interfaces"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Patterns"),": Help us to identify ways in which a problem can be solved. Much less thinking and working out.concre"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"LayoutMangers"),": Containers as their layout manager to do the work."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Strategy Pattern"),": Behavioural pattern. Allows objects behaviour to be changed at runtime. Code will remain the same, but layout manager will be specified.")),(0,i.kt)("h2",{id:"sub-type-polymorphism-and-interfaces"},"(Sub-type) Polymorphism and Interfaces"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Hides the data inside the class."),(0,i.kt)("li",{parentName:"ul"},"When using polymorphism to change the behaviour at runtime, dont care how its implemented inside the class. Only care what functions/methods are available."),(0,i.kt)("li",{parentName:"ul"},"An ",(0,i.kt)("strong",{parentName:"li"},"abstract")," method is a method without implementation"),(0,i.kt)("li",{parentName:"ul"},"If you have an abstract method, cannot create instances of the class"),(0,i.kt)("li",{parentName:"ul"},"Summary:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Need method(s) without implementation(s) (placeholder for sub-class to implement)"),(0,i.kt)("li",{parentName:"ul"},"These methods need to be labelled abstract"),(0,i.kt)("li",{parentName:"ul"},"If a class has an abstract method then the class must be labelled abstract too"),(0,i.kt)("li",{parentName:"ul"},"Cannot create instances of an abstract class."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Interfaces"),": If dont have any implementations for any of the methods, can use an interface instead of a class. Set of functions without implementations.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"A sub-class implements interfaces but extends a class"),(0,i.kt)("li",{parentName:"ul"},"Class only extend on class, and can implement many interfaces"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"JButton"),": Uses the Observer Pattern, and has an interface, the ",(0,i.kt)("inlineCode",{parentName:"li"},"ActionListener")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Observer Pattern"),": Common pattern to use when want to notify other objects the something happened.")),(0,i.kt)("h1",{id:"patterns--inner-classes"},"Patterns & Inner Classes"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Final"),": Variables (cant change value), methods(cant change implementation in subclass), classes(cant subclass them)")),(0,i.kt)("h2",{id:"patterns"},"Patterns"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Strategy Pattern"),": Often get scenarios where a class has a number of responsibilities and it can implement each in multiple different ways. ",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Decide on the set of responsibilities and create interface for them. "),(0,i.kt)("li",{parentName:"ul"},"Create different sub-classes which implement the responsibilities differently"),(0,i.kt)("li",{parentName:"ul"},"Give the main object  a reference to the object to use."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Observer Pattern"),": Notifying an object of a different class that an event occurred",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Caller knows that listener IS-AN ActionListner, so knows to call ",(0,i.kt)("inlineCode",{parentName:"li"},"actionPerformed()")," method to tell it when something happens.")))),(0,i.kt)("h2",{id:"inner-classes"},"Inner Classes"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"static"),": Not associated with object of outer class or not"),(0,i.kt)("li",{parentName:"ul"},"Classes inside another class."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Adaptors"),": Exist for many of the interfaces. These are classes which have empty implementations of the methods, so only implement the one that you want.")),(0,i.kt)("h1",{id:"parametrstrong-textic-polymorphism-and-boxing"},"Parametrstrong textic Polymorphism and Boxing"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Generic"),": Can use parametric polymorphism to make a class generic, which can store ANY type of object. One type which is parameterised on another type.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Parameterise the original class to avoid having to create different types. But still check the types at COMPILE time. "),(0,i.kt)("li",{parentName:"ul"},"Add ",(0,i.kt)("inlineCode",{parentName:"li"},"<T>")," after the class name"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Type Erasure"),": Type exists at compile time but not at runtime. This causes issues as removing the type at compile time means you cannot write code which needs to know the real type at runtime.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"To fix this can cast the object - because we know they are all of type T, from when we stored them."))),(0,i.kt)("li",{parentName:"ul"},"Int, boolean, float are NOT classes. For each basic data type there is a wrapper class, which will wrap up the data in an object"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Boxing"),": Wrapping up a data type in an object"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Unboxing"),": Extracting the data again"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Auto-boxing"),": Automatically doing this"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Parametric Polymorphism"),": Create classes which are generic.")),(0,i.kt)("h1",{id:"iterator-pattern"},"Iterator Pattern"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A method to move through (iterate through) the elements of something",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Iterable interface also exists, to create an Iterator"))),(0,i.kt)("li",{parentName:"ul"},"Iterable (on the counter to iterate through). Interface with a method to create an iterator. ",(0,i.kt)("inlineCode",{parentName:"li"},"Iterator<T> iterator()")),(0,i.kt)("li",{parentName:"ul"},"Iterator (object to do the iteration). Interface to allow checking if there is a next object and if so retrieving it and moving on. ",(0,i.kt)("inlineCode",{parentName:"li"},"boolean hasNext() \\n T next()"))),(0,i.kt)("h1",{id:"anonymous-classes"},"Anonymous Classes"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Inner classes with no name."),(0,i.kt)("li",{parentName:"ul"},"Class is defined at the same place as the object is created"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Lambda"),": Simpler syntax for an anonymous class when it sub-classes: an interface which has ",(0,i.kt)("strong",{parentName:"li"},"only one method")," ",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Compiler has to know to expect an interface, and to be able to work out the type of interface."),(0,i.kt)("li",{parentName:"ul"},"You give it an implementation of ",(0,i.kt)("strong",{parentName:"li"},"the")," method. (Only one method on the interface, knows return type and the parameter types)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"parameters")," ",(0,i.kt)("inlineCode",{parentName:"li"},"->")," ",(0,i.kt)("em",{parentName:"li"},"expression to evaluate to return the result value")))),(0,i.kt)("li",{parentName:"ul"},"Lambda expressions can also capture final variables from the surroundings. Think of it as putting a copy of this variable inside the Lambda."),(0,i.kt)("li",{parentName:"ul"},"Think of Lambda Expressions as a way of wrapping up a function in an object."),(0,i.kt)("li",{parentName:"ul"},"Can use sub-type polymorphism and treat it as the base-case in the code.")),(0,i.kt)("h1",{id:"design-patterns"},"Design Patterns"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Help us to identify ways which a problem can be solved"),(0,i.kt)("li",{parentName:"ul"},"If class has multiple responsibilities, best to split it into multiple classes."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Creational Patters"),": Patterns related to creation of objects.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Singleton"),": Only one instance of this class. Whenever anything wants an instance, give the same one. Basic ones use a static method"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Factory"),": Wrap up the creation of another object(s), particularly when you don't know what to create. Because factory creates the object for you, done need to know which precise sub-class it will create-can let the factory decide."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Similarities"),": Both had a method for creating objects for you."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Differences"),": Factory has an object which is responsible for creating the objects. Single has a static member function and always returns the same code.")))),(0,i.kt)("h2",{id:"design-pattern-summary"},"Design Pattern Summary"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Observer"),": tell me when something happens"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Strategy"),": lets another object modify the behaviour of an object"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Iterator"),": Lets you iterate through the contents"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Singleton"),": Create just one instance and use it anywher"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Simple Factory"),": Delegate the job of choosing which class to actually create to another object.")))}h.isMDXComponent=!0},202:function(e,t,a){t.Z=a.p+"assets/images/352f9b2d3f5195640e5c50f4dfe5fa0f-f087b0a6a2be2fd18d0557fbea9a4d92.png"}}]);