"use strict";(self.webpackChunknottes=self.webpackChunknottes||[]).push([[2388],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return d}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),u=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),c=u(n),d=i,k=c["".concat(s,".").concat(d)]||c[d]||m[d]||r;return n?a.createElement(k,l(l({ref:t},p),{},{components:n})):a.createElement(k,l({ref:t},p))}));function d(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,l=new Array(r);l[0]=c;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:i,l[1]=o;for(var u=2;u<r;u++)l[u]=n[u];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},769:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return s},default:function(){return d},frontMatter:function(){return o},metadata:function(){return u},toc:function(){return m}});var a=n(7462),i=n(3366),r=(n(7294),n(3905)),l=["components"],o={},s="Functional language",u={unversionedId:"Year1/Programming Paradigms/Haskell/Revision",id:"Year1/Programming Paradigms/Haskell/Revision",title:"Functional language",description:"++ - Appends list together",source:"@site/docs/Year1/1009 - Programming Paradigms/Haskell/Revision.md",sourceDirName:"Year1/1009 - Programming Paradigms/Haskell",slug:"/Year1/Programming Paradigms/Haskell/Revision",permalink:"/Year1/Programming Paradigms/Haskell/Revision",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"year1",previous:{title:"Introduction",permalink:"/Year1/Programming Paradigms/Haskell/22.03.23 - Lazy Evaluation"},next:{title:"Introduction to objects and Java",permalink:"/Year1/Programming Paradigms/Java/22.02.03 - Introduction to objects and Java"}},p={},m=[{value:"Function Application",id:"function-application",level:2},{value:"Types",id:"types",level:2},{value:"Foldr Function",id:"foldr-function",level:2},{value:"Other Library Functions",id:"other-library-functions",level:2},{value:"Data Declarations",id:"data-declarations",level:2},{value:"Recursive Types",id:"recursive-types",level:2},{value:"Arithmetic Expressions",id:"arithmetic-expressions",level:2}],c={toc:m};function d(e){var t=e.components,n=(0,i.Z)(e,l);return(0,r.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"functional-language"},"Functional language"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"++")," - Appends list together\n",(0,r.kt)("inlineCode",{parentName:"p"},":")," - Takes single item(number) and moves it into the list. Can also be used to break apart the list."),(0,r.kt)("h1",{id:"the-standard-prelude"},"The Standard Prelude"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"head")," - Select first number of list"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"tail")," - Remove the first element"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"!!")," - (Bang) Select the nth element of a list"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"take")," - Select the first n elements of a list"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"drop")," - Removes the first n elements"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"length")," - calculate the length of the list"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"sum")," - Calculate the sum of a list of numbers. Returns 0 if list is empty"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"product")," - Calculate the product of the list. Returns 1 if list is empty "),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"reverse")," - Reverses a list")),(0,r.kt)("h2",{id:"function-application"},"Function Application"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Function application is assumed to have higher priority than all other operators"),(0,r.kt)("li",{parentName:"ul"},"Means haskell does ",(0,r.kt)("inlineCode",{parentName:"li"},"(f a) + b")," rather than ",(0,r.kt)("inlineCode",{parentName:"li"},"f(a+b)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Naming Requirements"),": Function and argument names must begin with a lowercase. By convention list arguments usually have an ",(0,r.kt)("em",{parentName:"li"},"s")," suffix on their name."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Layout Rule"),": Each definition must begin in precisely the same column. Don't have to use specific grouping such as ",(0,r.kt)("inlineCode",{parentName:"li"},"{}"),".")),(0,r.kt)("h1",{id:"types-and-classes"},"Types and Classes"),(0,r.kt)("p",null,"Type error - Applying a function to one or more arguments of the wrong type"),(0,r.kt)("h2",{id:"types"},"Types"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Expression ",(0,r.kt)("inlineCode",{parentName:"li"},"e")," would produce a value of type ",(0,r.kt)("inlineCode",{parentName:"li"},"t"),". ",(0,r.kt)("inlineCode",{parentName:"li"},"e :: t")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Type Interface")," - Calculates the type of any expression."),(0,r.kt)("li",{parentName:"ul"},"Have ",(0,r.kt)("inlineCode",{parentName:"li"},"Bool"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"Char"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"String"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"Int"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"Float")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"List Types")," - ",(0,r.kt)("inlineCode",{parentName:"li"},"[t]")," is the type of lists with elements of type ",(0,r.kt)("inlineCode",{parentName:"li"},"t"),". This says nothing about its length."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Heterogeneous")," - Can only contain elements of the same type"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Tuple Types")," - Sequence of values of different types. The type of a tuple encodes its size and the components are unrestricted."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Function Types")," - Mapping from values of one type to values of another type. ",(0,r.kt)("inlineCode",{parentName:"li"},"even :: Int -> Bool"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Curried Functions")," -  Functions with multiple arguments are also possible by returning functions as results. These are functions which take them one at a time (",(0,r.kt)("em",{parentName:"li"},"add")," and ",(0,r.kt)("em",{parentName:"li"},"add`")," are different). More useful than functions on typles."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Currying Contentions")," - ",(0,r.kt)("inlineCode",{parentName:"li"},"->")," associates to the right. ",(0,r.kt)("inlineCode",{parentName:"li"},"mult x y z")," means ",(0,r.kt)("inlineCode",{parentName:"li"},"(mul x) y) z")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Polymorphic Functions")," - (Of many forms) if its type contains or more type variables.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Type variables must begin with a lower-case letter, usually named a,b,c"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"Polymorphic"),": This type has a type variable such as 'a'"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"Instantiate"),": Process of making an instance of an object using the class definition"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Overloaded Functions")," - Polymorphic function is called overloaded if its type contains one or more class constraints. 3 Types classes ",(0,r.kt)("inlineCode",{parentName:"li"},"Num")," (Numeric types), ",(0,r.kt)("inlineCode",{parentName:"li"},"Eq")," (Equal types), ",(0,r.kt)("inlineCode",{parentName:"li"},"Ord")," (Ordered types)")),(0,r.kt)("h1",{id:"defining-functions"},"Defining Functions"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Conditional Expressions")," - Must always have an else branch")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"signum :: Int -> Int\nsignum n = if n < 0 then -1 else\n            if n == 0 then 0 else 1\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Guarded Equations")," - ",(0,r.kt)("inlineCode",{parentName:"li"},"|")," means such that",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"abs n | n >= 0  = n\n            | otherwise = n\n")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"- **Pattern Matching** - `_` is a while card that matches any argument. Patterns are matched in order. Patterns must not repeat variables\n```haskell\nnot :: Bool -> Bool\nnot False = True\nnot True = False\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"List Patterns")," - Patterns must be parenthesised because application has priority over (:). (DOUBLE CHECK THIS)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Lambda Expressions")," - ",(0,r.kt)("inlineCode",{parentName:"li"},"\\.")," Constructed without naming the functions by using lambda expressions. Nameless funciton that takes a number x and returns the result x+x",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"Usefulness"),": Used to give formal mean to functions defined using currying. This can be used to avoid naming functions that are only referenced once."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Operator Sections")," - An operator written between its two arguments can be converted into a curried function written before its two arguments by using parentheses. (DOUBLE CHECK THIS)")),(0,r.kt)("h1",{id:"list-comprehensions"},"List Comprehensions"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Set Comprehensions")," - Comprehension notation can be used to construct new sets from old sets. ",(0,r.kt)("inlineCode",{parentName:"li"},"[x^2 | x <- [1..5]]"),". Changing the order of the generators changes the order of the elements in the final list. Multiple generators are like nested loops."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Dependant Generators")," - Depend on the variables that are introduced by earlier generators"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Guards")," - Use guards to restrict the values produced by earlier generators. Can define a function that maps a positive integer to its list of factors. ",(0,r.kt)("inlineCode",{parentName:"li"},"[x | x <- [1..10], even x]"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"zip function")," - Maps two lists to a list of pairs of their corresponding elements. Can define a function that returns the list of all positions of a value in a list. ",(0,r.kt)("inlineCode",{parentName:"li"},"zip :: [a] -> [b] -> [(a,b)]")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"String comprehensions")," - Any polymorphic function that operates on lists can also be applied to strings. List comprehensions can also work with them.")),(0,r.kt)("h1",{id:"recursive-functions"},"Recursive Functions"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Recursive Functions")," - Can also be defined in terms of themselves"),(0,r.kt)("li",{parentName:"ul"},"Some are simpler to define in terms of other functions but many can naturally be defined in terms of themselves."),(0,r.kt)("li",{parentName:"ul"},"Use of inductions can be applied to create a function"),(0,r.kt)("li",{parentName:"ul"},"Recursion not restricted to numbers, can also be used to define functions on lists."),(0,r.kt)("li",{parentName:"ul"},"Functions with more than one argument can also be defined using recursion")),(0,r.kt)("h1",{id:"higher-order-functions"},"Higher-Order functions"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Function is higher-order if it takes a function as an argument or returns a function as a result."),(0,r.kt)("li",{parentName:"ul"},"Useful:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Common programming idioms"),": Can be encoded as functions within the language itself"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Domain specific language"),": Can be defined as collections of higher-order functions"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Algebraic Properties"),": Of higher-order functions can be used to reason about programs."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"twice"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"map"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"filter"),", all examples of higher-order functions ")),(0,r.kt)("h2",{id:"foldr-function"},"Foldr Function"),(0,r.kt)("p",null,"Functions on lists can be defined using the following simple pattern of recursion (primitive recursion)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"f [] = v\nf (x:xs) = x ? f xs\n")),(0,r.kt)("p",null," ",(0,r.kt)("inlineCode",{parentName:"p"},"foldr")," (fold right) - encapsulates this simple pattern of recursion with the function ? and the value v as arguments. This takes care of all the recursion."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Think ",(0,r.kt)("inlineCode",{parentName:"li"},"foldr")," non-recursively, as simultaneously replaced each (:) in a list by a given function, and [] by a given value. This can be used to define many more functions than might first be expected"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Foldr")," - Building a function that does the matching and the recursion"),(0,r.kt)("li",{parentName:"ul"},"Why its useful:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Some recursive functions, like sum, are simpler to define using foldr"),(0,r.kt)("li",{parentName:"ul"},"Functions defined using foldr can be proved using algebraic properties of foldr, such as fusion and the banna split rule? (CHECK THIS)"),(0,r.kt)("li",{parentName:"ul"},"Advanced optimisations can be simplest if foldr is used in place of explicit recursion")))),(0,r.kt)("h2",{id:"other-library-functions"},"Other Library Functions"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},".")," - returns the composition of two functions as a single function"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"all")," - decides if every element of a list satisfies a given predicate"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"any")," - decides if at least one element of a list satisfies a predicate"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"takeWhile")," - selects elements from a list while a predicate holds all the elements"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"dropWhile")," - removes elements while a predicate holds of all the elements")),(0,r.kt)("h1",{id:"declaring-types-and-classes"},"Declaring Types and Classes"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"These can be used to make other types easier to read; ",(0,r.kt)("inlineCode",{parentName:"li"},"type String = [Char]")),(0,r.kt)("li",{parentName:"ul"},"Like function definitions, can also have parameters;",(0,r.kt)("inlineCode",{parentName:"li"},"type Pair a = (a,a)")),(0,r.kt)("li",{parentName:"ul"},"Can be nested but never recursive")),(0,r.kt)("h2",{id:"data-declarations"},"Data Declarations"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Can be defined by specifying its values using a data declaration;  ",(0,r.kt)("inlineCode",{parentName:"li"},"data Bool = False | True"),"."),(0,r.kt)("li",{parentName:"ul"},"Values of new types can be used in the same ways as those build in types. Type and constructor names bust always begin with an upper-case letter"),(0,r.kt)("li",{parentName:"ul"},"The constructor can also have parameters; ",(0,r.kt)("inlineCode",{parentName:"li"},"Rect :: Float -> Float -> Shape"))),(0,r.kt)("h2",{id:"recursive-types"},"Recursive Types"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Be declared in terms of themselves; ",(0,r.kt)("inlineCode",{parentName:"li"},"data Nat = Zero | Succ Nat")),(0,r.kt)("li",{parentName:"ul"},"Using recursion is easier to define functions that convert between values of type Nat and Int. Function can be defined without the need for conversions")),(0,r.kt)("h2",{id:"arithmetic-expressions"},"Arithmetic Expressions"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Simple form of expressions build up from integers using addition and multiplication. "),(0,r.kt)("li",{parentName:"ul"},"Many functions on expressions can be defined by replacing the constructors by other functions using a suitable fold function. ",(0,r.kt)("inlineCode",{parentName:"li"},"eval = folde id (+) (*)"))),(0,r.kt)("h1",{id:"interactive-programming"},"Interactive Programming"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Haskell programs have no side effects, however interactive programs have side effects."),(0,r.kt)("li",{parentName:"ul"},"Can be written in Haskell by using types to distinguish pure expressions from impure actions that may involve side effects."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"IO a")," - Returns the value of type a"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"getChar")," Adjugate - Reads a character from the keyboard, echos it to screen and returns it as a result"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"putChar c")," -  Writes the character c to the screen and returns no result value"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"return v")," - Returns the value v without performing any interaction."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"do")," - Combine a sequence of actions"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"getLine")," - Reads an entire string, Haskell reads each character one by one, returns it as a list."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"putStr")," - Writes a string to the screen"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"putStrLn")," - Writes a string and moves to new line"),(0,r.kt)("li",{parentName:"ul"},"Evaluating an action executes its side effects, with the final result value being discarded")),(0,r.kt)("h1",{id:"lazy-evaluation"},"Lazy Evaluation"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Avoids doing unnecessary evaluation. Two main strategies for deciding which reducible expression (redex) to consider next."),(0,r.kt)("li",{parentName:"ul"},"Choose a main redex that is innermost, does not contain another redex"),(0,r.kt)("li",{parentName:"ul"},"Choose a redex that is outermost, not contained in another redux."),(0,r.kt)("li",{parentName:"ul"},"Outermost evaluation may give a result when innermost fails to terminate."),(0,r.kt)("li",{parentName:"ul"},"Lazy evaluation = outermost evaluation + sharing of arguments."),(0,r.kt)("li",{parentName:"ul"},"Lazy Evaluation ensures termination whenever possible, but never requires more steps than innermost evaluation, sometimes fewer."),(0,r.kt)("li",{parentName:"ul"},"In general, they are only evaluated as much as required by the context in which they are used."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Modular Programming")," - Allows us to make programs more modular by separating control from data. Without using this, the control and data parts would need to be combined into one")))}d.isMDXComponent=!0}}]);